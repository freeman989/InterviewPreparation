package com.answers;

import java.util.ArrayList;
import java.util.List;

public class JPA_Hibernate {

    public static List<String> jpa_hibernate = new ArrayList<>();

    static {
        jpa_hibernate.add("- ORM(Object Relational Mapping) - это концепция преобразования объекта в строку в таблице БД и наоборот. \n" +
                "JPA(Java Persistence API) - это такая спецификация для Java, которая описывает принципы ORM. Т.е. каким образом сохраняется объект в таблице БД и наоборот. // JPA не работает с объектами, а только определяет правила как должны действовать провайдеры. Например Hibernate - является одним из этих провайдеров. Также // еще есть EclipseLink и др. \n" +
                "Hibernate - библиотека, она как раз реализует эту спецификацию JPA, работает по ее правилам. Это такой слой между базой данных и приложением на Java.\n" +
                "\n" +
                "// Сначала появился Хибер, а потом по нему уже сделали JPA. На основании Хибера создали стандарт JSR.\n" +
                "\n" +
                "Важные интерфейсы Hibernate: \n" +
                "* Session - соединяет (физически) приложение с БД. С помощью нее можно выполнять DML-операции в базе данных через объектно-ориентированные сущности.\n" +
                "* SessionFactory - это фабрика для объектов Session. Она создается при запуске приложения и может использоваться всеми потоками приложения.\n" +
                "Пример: Session session = sessionFactory.openSession();\n" +
                "* Transaction - однопоточный короткоживущий объект, используемый для атомарных операций. В одной Session может быть несколько Transactionов. \n" +
                "* Query - это такой интерфейс, с помощью него можно выполнять запросы к БД с помощью языков HQL или на SQL.\n" +
                "Пример: \n" +
                "Query query = session.createQuery(\"from Human where name = 'Yura'\");\n" +
                "List list = query.list();\n" +
                "\n" +
                "// HQL - Hibernate Query Language - это язык для объектно-ориентированных запросов.");
        jpa_hibernate.add("- EntityManager это интерфейс JPA. Он управляет сущностями Entity, он не является потокобезопасным.\n" +
                "Он содержит внутри себя методы - необходимые для операций над сущностью и ее данными. \n" +
                "EntityManager - создается с помощью фабрики EntityManagerFactory. Пример: EntityManager entityManager = entityManagerFactory.createEntityManager();\n" +
                "Основные операции:\n" +
                "1) Операции над Entity (методы): persist (сохраняет Entity в БД), merge (обновление данные в БД в соответствии с сущностью, которую ему передали), \n" +
                "remove (удаление), refresh (обновляет данные сущности из БД), \n" +
                "detach (выводит из под контроля EntityManagera), lock (блокирование Entity от изменений в других потоках).\n" +
                "2) Получение данных: find(поиск Entity), createQuery(), createNamedQuery(), createNativeQuery(), contains(), createStoredProcedureQuery().\n" +
                "3) Получение других сущностей JPA: getTransaction(), getEntityManagerFactory(), getCriteriaBuilder(), getMetamodel(), getDelegate\n" +
                "4) Работа с EntityGraph: createEntityGraph(), getEntityGraph().\n" +
                "5) Общие операции над EntityManager или над всеми Entities: close(), clear(), isOpen(), getProperties(), setProperty().\n" +
                "\n" +
                "// EntityManager работает с PersistentContextom - внутри которого находится набор, либо вновь созданных сущностей, либо выгруженных из БД.\n" +
                "\n" +
                "// В JPA EntityManager идет как аналог Session в Hibernate.\n" +
                "\n" +
                "// Объекты EntityManager не являются потокобезопасными. Это означает, что каждый поток должен получить свой экземпляр EntityManager, поработать с ним и закрыть его в конце.\n" +
                ">> С помощью Entity Graph можно менять стратегию FetchType.EAGER или FetchType.LAZY во время выполнения программы.");
        jpa_hibernate.add("- Entity это - легковесный хранимый объект бизнес логики. \n" +
                "- А если по простому, Entity - это сущность (POJO-class) которая может быть сопоставлена с таблицей в реляционной БД. \n" +
                "Получается - сущность Entity будет являться таблицей в БД, а каждый экземпляр Entity будет являться строкой в БД. \n" +
                "1) Entity класс должен быть помечен аннотацией Entity или описан в XML файле\n" +
                "2) Entity класс должен иметь пустой конструктор (без аргументов, публичный или протектед). // И иметь сеттеры и геттеры.\n" +
                "Потому что - при получении данных из БД, Hibernate, из полученных данных, формирует объект сущности. \n" +
                "3) Entity класс должен быть классом верхнего уровня. Т.е. класс не должен быть вложенным.\n" +
                "4) Entity класс не может быть enum или интерфейсом. \n" +
                "5) Entity класс не может быть финальным классом (final class). \n" +
                "6) Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге. (А если не учавствуют, то можно). \n" +
                "7) Если объект Entity будет передаваться по значению как отдельный объект, например через удаленный интерфейс, он должен реализовывать Serializable. \n" +
                "8) Поля Entity класса должны быть доступны только методам самого Entity и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к getterам, setterам или другим его методам. \n" +
                "9) Entity класс должен быть с аннотацией @ID, которая идентифицирует первичный ключ, который делает его уникальным при записи этого Entity в базе данных\n" +
                ".");
        jpa_hibernate.add("- Может. Так как он сохраняет все свойства Entity. Но только его нельзя непосредственно инициализировать.");
        jpa_hibernate.add("- Может.\n" +
                "Но только состояния полей обычного класса-родителя не могут быть персистентным, и не смогут сохраняться в БД, и вообще не будут обрабатываться Hibernatом.");
        jpa_hibernate.add("- Да. Может. // Ну просто может. Таковы правила в Hibernate.");
        jpa_hibernate.add("- Тоже может. // Здесь - тоже самое с полями и их обработкой Hibernaitoм.");
        jpa_hibernate.add("- Встраиваемый класс - это класс, он не является самостоятельным, а является частью (компонентом) другого, какого-то одного или же нескольких Entity-классов. \n" +
                "Внутри Entity-класса может находиться как один встраиваемый класс, так и коллекция встраиваемых классов. \n" +
                "Также такие классы могут быть использованы как ключи или значения map. \n" +
                "Во время выполнения программы, каждый встраиваемый класс принадлежит только одному объекту Entity-класса и не может быть использован кем-то еще. \n" +
                "\n" +
                "- Требования к встраиваемым классам:\n" +
                "1. В нем не требуется аннотация @Entity и @ID, а в остальном они должны соблюдать те же правила что классы Entity. \n" +
                "2. Поле этого класса внутри Entity должно быть с аннотацией @Embedded. \n" +
                "А сам Embeddable-класс помечается аннотацией @Embeddable (или описан в XML файле конфигурации JPA). \n" +
                "Также Embeddable-класс может, внутри себя, содержать другой (Embeddable) встраиваемый класс.");
        jpa_hibernate.add("- Mapped Superclass - это класс, от которого может наследоваться Entity, но при этом ему не обязательно выполнять все требования как в Entity. \n" +
                "Он помечается аннотацией @MappedSuperClass (или описывается в xml файле).\n" +
                "В нем не требуется первичный ключ. В нем не прописывается аннотация @Entity.\n" +
                "И классы которые наследуются от него, они получают состав своей структуры, т.е. все поля перечисленные в том классе.\n" +
                "\n" +
                "- Общее между Embeddble и Mapped Superclassom - то что они являются - общей структурой, которая потом передается в другие классы. \n" +
                "И общее в том что они оба не являются Entity, соответственно не могут иметь своих таблиц в БД. \n" +
                "И также не могут учавствовать в запросах EntityManagera и Query. \n" +
                "\n" +
                "А разница в том что - встраиваемые(Embeddble) классы они получается встраиваются как тип от названного класса, \n" +
                "а Mapped Superclass - там транслируются поля от родителя, в структуру наследника.\n" +
                "\n" +
                "// Сам такой класс хоть и не является Entity, но может содержать некоторые анотации JPA.  \n" +
                "// С помощью MappedSuperclassа можно заранее определить свойства и методы, для сущностей. Это позволяет сократить количество кода. \n" +
                "// Я так понял, это что-то наподобие абстрактного класса, но только он не является Entity.\n" +
                "// Если унаследоваться от MappedSuperClassa каким то Entity, то таблица класса Entity будет создана, а таблица из MappedSuperClassa не будет.");
        jpa_hibernate.add("- Стратегии наследования нужны для того, чтобы дать понять Hibernatу как ему надо отображать в БД сущностей-наследников. \n" +
                "Для этого родительский класс помечается аннотацией @Inheritance и там нужно указать один из типов отображения: SINGLE_TABLE, TABLE_PER_CLASS, JOINED.\n" +
                " \n" +
                "1. SINGLE_TABLE. - это одна таблица. Когда предок и наследник записываются в одну таблицу (т.е. одна таблица для всей иерархии классов). \n" +
                "И в ней создается специальная колонка (“discriminator column”). И в этой колонке идентифицируются, к какому типу(классу) относится данная запись. \n" +
                "И формируются еще дополнительные колонки в которых сохраняются специфические данные.\n" +
                "Например у нас предок Animal, а дальше - от нее идут наследники собака и кошка. Т.е. у кошки какие-то свои специфические данные и у собаки свои. И они не пересекаются. (Данная стратегия является стратегией по умолчанию).\n" +
                "Минусом является то что у нас в общей таблице, будут созданы все поля уникальные для каждого из классов-потомков, и они могут быть пустыми для всех остальных классов-потомков. И так как - на специфические типы, в колонках, мы не можем наложить ограничение NotNULL. И это может привести к неопределенному моменту.\n" +
                "Например, в таблице animals окажется и скорость лазанья по дереву (от кошки) и может ли собака приносить палку.\n" +
                "И они всегда будут иметь null, и для собаки и для кошки.\n" +
                "// В реляционной базе данных у нас нету классов. Там у нас есть типы. (Сказал В...).\n" +
                "\n" +
                "2. TABLE_PER_CLASS. - Это значит что у каждого конкретного класса-сущности будет своя собственная таблица, со всеми полями, включая поля родителя. \n" +
                "Но у этой стратегии минус, в том что приходится делать несколько запросов, или объединять их через UNION. То есть не поддерживаются полиморфизм. \n" +
                "\n" +
                "3. JOINED. - Здесь создается общая таблица для предка и наследников. И в эту таблицу записываются общие данные. \n" +
                "А для специфических данных создаются отдельные таблицы, и в них записываются уникальный ключ и специфические данные.  \n" +
                "Потом между этими таблицами дополнительно устанавливается связи. И если взять пример из классов Animals, то будут три таблицы: animals, cats, dogs. \n" +
                "Т.е. в cats будет записаны: только ключ и скорость лазанья, в dogs — ключ и умеет ли собака приносить палку, а в animals все остальные данные. \n" +
                "Минусом тут будет потери производительности из-за объединения таблиц (join) для каких-либо операций.\n" +
                "Т.е. - когда у нас слишком большая иерархия выстраивается, и при большой иерархии может наступить определенный момент, после чего как-раз начинает теряться эта самая производительность. Т.е.когда иерархия достигает больших пределов наследования. ");
        jpa_hibernate.add("Для того чтобы замапить Enum нужно использовать аннотацию @Enumerated. И мапятся они либо по имени , либо по порядковому номеру в Enume.\n" +
                "И задается это в параметрах @Enumerated. (По умолчанию мапится по индексу - EnumType.ORDINAL).\n" +
                "\n" +
                "Недостаток EnumType.ORDINAL: Так как у нас в базе данных хранятся только индексы, они не привязаны к самому Enumu, т.е. значения. У нас получается,\n" +
                "при добавлении элементов в СЕРЕДИНУ, в базе данных вся информация просто сбивается. И для этого у нас как раз вводят Stringи, чтобы в базе данных хранилось наименование Enuma. Это основной недостаток при хранении через ORDINAL. \n" +
                "А если Stringoй храним, то соответственно у нас, при добавлении нового значения ничего не меняется, но при этом - если мы хотим переименовать саму константу,\n" +
                "то у нас опять таки возникает ошибка - что теряется значение в базе данных, которое уже не соответствует ни одному значению из нашего Enuma. \n" +
                "И для этого у нас две методологии появились:\n" +
                "1. Написать свой конвертер. Пишем класс с аннотацией @Converter, и поле которое нужно мапить, мы его прописываем с аннотацией @Convert. И тогда будет использоваться класс соответствующий при конвертации этого Enuma.\n" +
                "Потом (как сказал В...) Мы над полем Enumа, непосредственно который сам Enum - ставим аннотацию @Transient. А в базу данных уже именно значения конвертера с этого Enuma вносим.\n" +
                "Например: Есть у нас сущность, а в ней поле Enum, которое обычным способом в БД ОРЭмится так сказать, то здесь - когда мы вводим конвертер (класс которого пишется отдельно), чтобы Enum при этом у нас уже не вносился в БД, а только конвертация этого Enuma, то как раз таки над Enumom мы и ставим @Transient.\n" +
                "То есть - он в БД уже попадать не будет, а только значение конвертации. \n" +
                "- - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  \n" +
                "- 1). По порядковым номерам. \n" +
                "Для этого используется аннотация @Enumerated(EnumType.ORDINAL) - означает что в базе будут храниться порядковые номера Enum.\n" +
                "При этом в таблице нашей сущности создаётся колонка для значений перечисления enum и по умолчанию в ячейки сохраняется порядковый номер этого перечисления.\n" +
                "\n" +
                "- 2). По именам. \n" +
                "Здесь используется аннотация @Enumerated(EnumType.STRING). Это означает, что в базе будут храниться имена Enum. \n" +
                "С @Enumerated(EnumType.STRING) можно добавлять значения перечисления или изменять порядок перечисления. Потребляет больше места, чем в случае с ORDINAL. И когда надо будет работать с большим объемом данных, то из-за этого могут возникнуть проблемы.\n" +
                "- @Enumerated(EnumType.STRING) - означает, что в базе будут храниться имена Enum. \n" +
                "\n" +
                "Также - enum можно смапить, в БД и обратно, в методах с аннотациями @PostLoad и @PrePersist. \n" +
                "Здесь сущность может содержать в себе не только поле с Enum, но и вспомогательное поле. (Вспомогательное поле нужно потому что у Enuma нет айдишника).\n" +
                "Таким образом мы можем пометить поле с Enum аннотацией @Transient, а в БД будет храниться значения из этого вспомогательного поля. \n" +
                "Также в JPA (с версии 2.1) можно использовать Converter для конвертации Enum’а в такое значение - чтобы его можно было сохранить в БД и получить из БД. \n" +
                "Для этого нужно создать класс, который будет реализовывать интерфейс AttributeConverter и аннотировать его с помощью @Converter и поле в сущности аннотацией @Convert.");
        jpa_hibernate.add("- До Java 8 даты можно было мапить с помощью аннотации @Temporal, в ее параметрах надо было указать какой тип даты мы хотим использовать.\n" +
                "Пример: @Temporal(TemporalType.DATE) , @Temporal(TemporalType.TIME), @Temporal(TemporalType.TIMESTAMP).\n" +
                "А после 8-ой Javы никакие аннотации уже не нужны. То есть - она сама определяет что это дата, и какой у нее тип.\n" +
                "Там появился специальный пакет java.time. а до этого использовался пакет java.util.\n" +
                "Разница между ними в том что в пакете java.util точность измерения до миллисекнуд, а в пакете java.time точность до наносекунд (т.е. в миллион раз выше).\n" +
                "\n" +
                ">>> Если что: Маппить на русском значит \"сопоставлять\".");
        jpa_hibernate.add("- Чтобы смапить коллекцию примитивов - используется аннотация @ElementCollection. Она указывается в классе сущности над полем коллекции с примитивами. \n" +
                "Для сохранения коллекции создается отдельная таблица. В итоге получим две таблицы: одна для сущности, а вторая для коллекции элементов. \n" +
                "И в этой таблице никаких идентификаторов нет. Поэтому, если значение в коллекции изменяется, то - оно перезаписывает, полностью - все что там хранилось. Таблица очищается и заполняется заново. \n" +
                "\n" +
                "// Аннотация @ElementCollection похожа на отношение @OneToMany, только здесь используются базовые и встраиваемые типы, а не сущности. \n" +
                "// При добавлении новой строки в коллекцию, она полностью очищается и заполняется заново, так как у элементов нет id. (Можно решить с помощью @OrderColumn\n" +
                "). \n" +
                "// @OrderColumn - указывает столбец, который используется для поддержания постоянного порядка в списке.\n" +
                "// @CollectionTable - позволяет редактировать таблицу с коллекцией, прочитать.\n" +
                "\n" +
                "// Если у нашей сущности есть поле с коллекцией, то мы привыкли ставить над ним аннотации @OneToMany либо @ManyToMany. \n" +
                "// Но такие аннотации применяются в случае, когда это коллекция других сущностей (entities). ");
        jpa_hibernate.add("- Существуют 4 типа связей: \n" +
                "1. OneToOne - когда один экземпляр Entity может быть связан не больше чем с одним экземпляром другого Entity.\n" +
                "2. OneToMany - когда один экземпляр Entity может быть связан с несколькими экземплярами других Entity. \n" +
                "3. ManyToOne - обратная связь для OneToMany. Несколько экземпляров Entity могут быть связаны с одним экземпляром другого Entity.\n" +
                "4. ManyToMany - экземпляры Entity могут быть связаны с несколькими экземплярами друг друга.\n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - -- -\n" +
                "Каждый тип связи может быть однонаправленным и двунаправленным. \n" +
                "- Однонаправленная связь - она предполагает что, один объект ссылается на другой, а в обратную сторону ссылки нет. \n" +
                "А при двунаправленной связи - оба объекта знают друг про друга, т.е. хранят ссылку друг на друга.  \n" +
                "- - - - - - - - - - -- - - - - - - --  - - - --- --- - - -\n" +
                "Каждую из которых можно разделить ещё на два вида: \n" +
                "1. Bidirectional с использованием mappedBy на стороне, где указывается @OneToMany\n" +
                "2. Unidirectional\n" +
                "Bidirectional — ссылка на связь будет у обоих Entity, то есть в случае OneToOne A-B в Entity A есть ссылка на Entity B, в Entity B есть ссылка на Entity A. И при этом Entity A считается владельцем этой связи.\n" +
                "Undirectional - ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только у Entity A будет ссылка на Entity B, у Entity B ссылки на A не будет, и он даже знать не будет что на него кто-то ссылается.\n" +
                "\n" +
                "// Пример с автомобилями и их владельцем при удалении владельца.");
        jpa_hibernate.add("- Владелец связи это тот кто хранит ссылку (внешний ключ) на другую сущность. (т.е. есть владелец и есть владеемая сущность).\n" +
                "И когда связь многие ко многим, то тут уже получается неопределенность, потому что - оба объекта хранят ссылки друг на друга.\n" +
                "Но также можно и установить владельца связи вручную (Например в @ManyToMany - можно указать атрибут mappedBy). \n" +
                "\n" +
                "А вот аннотация @ManyToOne автоматически подразумевает что сторона Many - является владельцем, и поэтому у этой аннотации отсутствует атрибут mappedBy.\n" +
                "- - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n" +
                "- В отношениях между двумя сущностями всегда есть одна владеющая сторона (а владеемой может и не быть). Это называется однонаправленное отношение.    \n" +
                "В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем этой связи по умолчанию. ");
        jpa_hibernate.add("- Каскады (JPA CascadeType) - это связи между основной связанной сущностью и дочерней связанной сущностью (сущностями). \n" +
                "Они определяют поведение со связанной сущностью в зависимости от состояния основной сущности.\n" +
                "\n" +
                "* Т.е если там будет ALL - то все что происходит с основной сущностью, то же будет происходить и со связанной. \n" +
                "* Когда PERSIST -  означает, что операции save() или persist() каскадно передаются связанным объектам.\n" +
                "* Когда MERGE - то когда объединяется основная сущность, тогда же объединяются и связанные сущности. \n" +
                "* Потом - REMOVE, - это удаление основной сущности - вызовет удаление связанной сущности. \n" +
                "* DETACH - также отключается из под управления JPA основная сущность и связанная сущность. \n" +
                "* И REFRESH - это значит - из базы данных обновляются - основная сущность и связанная. \n" +
                "\n" +
                "//= Про удаление сирот - что можешь рассказать?\n" +
                "//- orphan_removal - есть такой параметр у аннотаций взаимосвязей. В переводе сиротский приют называется. Т.е. когда мы удаляем родителя, и у нас в БД - //остаются сироты, как раз когда мы пишем - orphan_removal в каскаде, тип REMOVE либо ALL - у нас БД автоматически отыскивает этих сирот и удаляет. \n" +
                "//Т.е. чтобы не засорять память в БД. Мы просто ставим аннотацию, но параметр orphan_removal и при удалении родительской сущности - дочерние удаляются //автоматически. Они не останутся в БД. Только будет происходить это автоматически, на уровне БД. Для этого нам достаточно просто указать как раз только\n" +
                "//этот orphan_removal. Это указывается в видах связей, например в OneToMany (т.е. не в самих каскадах). OneToMany - и у нее есть один из параметров, это \n" +
                "//orphan_removal (сиротский приют). \n" +
                "\n" +
                ">>> Родительская сущность (таблица) Это сущность (таблица), на которую ссылается внешний ключ из дочерней сущности (таблицы). \n" +
                ">>> Дочерняя сущность (таблица) Это сущность (таблица), в которой есть колонка с внешним ключом, ссылающимся на родительскую сущность (таблицу).");
        jpa_hibernate.add("* LAZY - это ленивая загрузка, т.е. когда загружается основная сущность, а связанные не загружаются. Загрузка связанных сущностей произойдет только при первом обращении к ним. \n" +
                "* EAGER - это жадная загрузка, там данные загружаются сразу, вместе с основной сущностью все связанные сущности тоже загружаются. \n" +
                "- Значит, EAGER - загрузка по умолчанию установлена на все отношения которые заканчиваются на toONE, а также @Basic, там тоже он по умолчанию стоит.\n" +
                "- А LAZY-загрузка, по умолчанию, на все, которые заканчиваются на toMany, а также и у @ElementCollection тоже по умолчанию. ");
        jpa_hibernate.add("- New - это когда объект создан, но еще не перешел под управление JPA. // и пока еще не имеет связи с базой данных, и не имеет первичных ключей.\n" +
                "- Managed - это когда выполнена команда persist(), и сущность создана, и получает Primary Key, и сохраняется в БД. Устанавливается прямое соответствие меджду сущностью и записью в БД. //Здесь сущность получает primary key, и уже управляется JPA\n" +
                "- Removed - это когда сущность еще управляется JPA, но при коммите она будет удалена. \n" +
                "// И статус станет detached. А до тех пор объект все еще будет управляться JPA.\n" +
                "(Мы его пометили на удаление, и до коммита он еще находится в контексте).\n" +
                "- Detached - это сущность, которая уже вышла из под управления JPA. В этом состоянии сущность не связана со своим контекстом (отделена от него) \n" +
                "и нет экземпляра Session, который бы ей управлял. (т.е. мы ее удалили из контекста). \n" +
                "\n" +
                "- - - - - - - - - -- - - - -- - - - - - - -- - - -- - - - - -- - - - - -  - -\n" +
                "= А в каких статусах имеется первичный ключ? \n" +
                "- В Managed, и в Removed (еще наверноое). ");
        jpa_hibernate.add("- Из состояния new > (по команде persist()) переходит в состояние managed. Т.е. сущность получает первичный ключ и связь с БД. \n" +
                "// Значит объект сущности будет сохранен в базу при commit-е транзакции или в результате flush() операций\n" +
                "- Если уже находится в состоянии managed, то игнорируется. \n" +
                "- Если detached, то будет exception. // сразу или на этапе commit-а транзакции. \n" +
                "- Если removed, то переходит в состояние managed. (но только в рамках одной транзакции).");
        jpa_hibernate.add("- new > операция игнорируется. // но зависимые Entity могут поменять статус на removed, при условии что у них есть аннотации каскадных изменений и они имели статус managed. \n" +
                "managed > removed и запись объекта в базе данных будет удалена при commit-е транзакции (также произойдут операции remove для всех каскадно зависимых объектов). \n" +
                "detached > exception сразу или на этапе commit-а транзакции. \n" +
                "removed > операция игнорируется. ");
        jpa_hibernate.add("- Из состояния new перейдет в состояние managed. Будет создана новая сущность. // в которую будут скопированы данные прошлого объекта.\n" +
                "- Для managed будет игнор. \n" +
                "- Для detached - тоже переводит в managed. \n" +
                "- А в removed будет исключение. (сразу или на этапе commit-а транзакции\n" +
                ").");
        jpa_hibernate.add("- Когда managed, то данные нашего Entity обновятся из базы данных. // также произойдет refresh всех каскадно зависимых объектов.\n" +
                "- А во всех остальных состояниях (new, removed, detached) > вылетит exception\n" +
                ". ");
        jpa_hibernate.add("- Если managed, или removed > то будет detached.\n" +
                "- А если new и detached > то операция игнорируется\n" +
                ". ");
        jpa_hibernate.add("- Эта аннотация обозначает простейший тип маппинга. И поддерживает два параметра.\n" +
                "- Optional - это который говорит о том - может ли поле содержать Null или не может. \n" +
                "- И другой параметр Fetch - там задается, как будут извлекаться данные, ну там жадная загрузка или ленивая загрузка. \n" +
                "И по умолчанию включена жадная загрузка и допускается Null. \n" +
                "\n" +
                "= А какие типы вообще могут быть помечены в Basic?\n" +
                "- Это применяется к полям-примитивам, к их оберткам, BigDecimal, BigInteger, строки. И классы даты и времени. Также byte[], char[]\n" +
                "- - - - - - - - -- - - - - - - - - - - -- -- - - - - -- - - - - - - - - - - - -\n" +
                "- @Basic - указывает на простейший тип данных, который будет мапиться в таблицу. \n" +
                "Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет. \n" +
                "Может быть применена к полю любого из следующих типов:\n" +
                " \n" +
                "- Примитивы и их обертки, String\n" +
                ", BigInteger\n" +
                ", BigDecimal\n" +
                ", Date, Calendar, Date, Time, Timestamp\n" +
                ", byte[] или Byte[], char[] или Character[], Enumы\n" +
                "и любые другие типы, которые реализуют Serializable. \n" +
                "\n" +
                "Вообще, аннотацию @Basic можно не ставить, как это и происходит по умолчанию.\n" +
                "\n" +
                "Аннотация @Basic имеет 2 атрибута: \n" +
                "1. Оptional - boolean (по умолчанию true) - определяет, может ли значение поля или свойства быть null. \n" +
                "// Для примитивных типов игнорируется. Но если тип поля не примитивного типа, то при попытке сохранения сущности будет выброшено исключение. \n" +
                "2. FetchType (по умолчанию EAGER) - определяет, должен ли этот атрибут извлекаться сразу же (EAGER) или лениво (LAZY). Однако, это необязательное требование.\n" +
                "// Без аннотации @Basic при получении сущности из БД по умолчанию её поля базового типа загружаются по EAGERу и значения этих полей могут быть null.");
        jpa_hibernate.add("- Эта аннотация связывает поле сущности с колонкой в БД. И вместе с этой аннотацией могут задаваться ограничения с которыми данные записываются в эту колонку\n" +
                "Т.е. то что - уникальное значение должно быть, не должно быть, Null, длина может задаваться. \n" +
                "\n" +
                "= А основное отличие @Basic от @Column какое у нас?\n" +
                "- @Column - относится к столбцу в БД. А @Basic он относится к сущности в JPA. \n" +
                "- - - - -- -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -- - - -\n" +
                "- @Column указывает что поле класса будет столбцом таблицы, а её атрибуты определяют поведение в этом столбце, используется для генерации схемы базы данных.\n" +
                "В чем разница? @Basic vs @Column: \n" +
                "Если коротко, то в Column (колум) мы задаем constraints (ограничения), а в Basic (бейсик) - FetchType.\n" +
                "1. Атрибуты @Basic применяются к сущностям JPA, тогда как атрибуты @Column применяются к столбцам базы данных.\n" +
                "2. @Basic имеет атрибут optional, который говорит о том, может ли поле объекта быть null или нет; \n" +
                " а @Column имеет атрибут nullable который указывает, может ли соответствующий столбец в таблице быть null или нет? \n" +
                "3. Мы можем использовать @Basic, чтобы указать, что поле должно быть загружено лениво. \n" +
                "4. Аннотация @Column позволяет нам указать имя столбца в таблице и ряд других свойств:\n" +
                "   a. insertable/updatable - можно ли добавлять/изменять данные в колонке, по умолчанию true;\n" +
                "   b. length - длина, для строковых типов данных, по умолчанию 255. ");
        jpa_hibernate.add("- Аннотация @Access - определяет доступ к атрибутам сущности. И доступ может быть как к полям, так и к свойствам. Т.е. либо FIELD либо PROPERTY. \n" +
                "Значит, самый простой способ - в общем Access определяет, т.е. доступ определяется по тому где указана аннотация, т.е. если аннотация указана над полем, то значит доступ будет непосредственно к полю - это тип FIELD. А если аннотация указана у геттера, то значит будет доступ к PROPERTYES. \n" +
                "А если мы не указываем аннотацию @Access, то Хибер определит доступ по ID-шнику. Т.е. он посмотрит над каким полем, либо методом стоит аннотация @ID. \n" +
                "И исходя из этого уже определит тип доступа.  \n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -- - - - - - - - - - - \n" +
                "- Она определяет тип доступа для класса entity, (Mapped)суперкласса, embeddable и их атрибутам, \n" +
                "а именно - как JPA будет обращаться к атрибутам entity: как к полям класса или как к свойствам класса, которые имеют гетеры и сетеры.\n" +
                "Короче - определяет тип доступа к полям сущности. \n" +
                "Для чтения и записи этих полей есть два подхода: \n" +
                "1. Field access (доступ по полям). При таком способе аннотации маппинга (Id, Column,...) размещаются прямо над полями, и Hibernate напрямую работает с полями сущности, читает их и записывает их.\n" +
                "2. Property access (доступ по свойствам). При таком способе аннотации размещаются над методами-геттерами, но никак не над сеттерами.\n" +
                "\n" +
                "- По умолчанию тип доступа определяется местом, в котором находится аннотация @Id. \n" +
                "Если она будет над полем - это будет AccessType.FIELD, если над геттером - это AccessType.PROPERTY.\n" +
                "Чтобы явно определить тип доступа у сущности, нужно использовать аннотацию @Access, которая может быть указана у сущности, Mapped Superclassа или Embeddable classа, а также над полями или методами. \n" +
                "Поля, унаследованные от суперкласса, имеют тип доступа этого суперкласса. \n" +
                "Когда у одной сущности определены разные типы доступа, то нужно использовать аннотацию @Transient для избежания дублирования маппинга.\n" +
                "И еще: есть одно условие для свойств: методы getFirstName и setFirstName для чтения и записи должны иметь такие же имена как у поля в БД.");
        jpa_hibernate.add(">>> Кэширование технология (предоставляемая ORM фреймворками), которая помогает достичь высокую скорость. Благодаря кэшированию - в базу данных приходится делать меньше запросов, благодаря чему и обеспечивается высокая скорость. По умолчанию включен кэш первого уровня.\n"+
                "\n"+
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n" +
                "- @Cacheable - это для работы с кэшем второго уровня. \n" +
                "Аннотация размещеется над классом сущности. Ну эта аннотация говорит, должна ли сущность храниться в кэше второго уровня или нет. И там есть пять уровней: \n" +
                "- ALL - это - все сущности кэшируются. \n" +
                "- NONE - не кэшируется ни одна. \n" +
                "- ENABLE_SELECTIVE - это значит, разрешает кэшироваться, те которые, сущности которые помечены. \n" +
                "- DISABLE_SELECTIVE - кэширует все кроме тех которые помечены как некэшируемые @Cacheable(value=false).\n" +
                "- И еще есть UNSPECIFIED - там помоему как-то по умолчанию начинает работать. Там подразумевает что передает под управление Хиберу, по умолчанию.  \n" +
                "А так как у нас Хибер по умолчанию не имеет своей реализации кэша второго уровня, то это равносильно тому что кэш второго уровня отключен.\n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n" +
                "- @Cacheable - необязательная аннотация JPA, используется для указания того, должна ли сущность храниться в кэше второго уровня или нет. \n" +
                "В JPA есть всего пять значений, которые определяют как будет использоваться этот second-level cache:\n" +
                "? ENABLE_SELECTIVE: означает что сущности с аннотацией @Cacheable будут сохраняться в кэше второго уровня.\n" +
                " (значению по умолчанию @Cacheable(value=true))\n" +
                "? DISABLE_SELECTIVE: в кэше второго уровня, будут сохраняться все сущности, кроме тех что помечены как некэшируемые @Cacheable(value=false).\n" +
                "? ALL: сущности всегда кэшируются, даже если они помечены как некэшируемые.\n" +
                "? NONE: ни одна сущность не кэшируется, даже если помечена как кэшируемая. \n" +
                "? UNSPECIFIED: для кэша второго уровня применяются значения по умолчанию. \n" +
                "Аннотацию @Cacheable ставят над классом сущности. Её действие распространяется на эту сущность и её наследников.");
        jpa_hibernate.add("- @Embeddable - размещается над классом для указания того, что класс является встраиваемым в другие классы, \n" +
                "то есть поля этого Embeddeble класса будут добавляться к полям других сущностей и будут представлять столбцы в таблице этой сущности. \n" +
                "Встраиваемый класс сам не является сущностью. \n" +
                "\n" +
                "@Embedded Аннотация - размещается над полем в классе-сущности и указывает на то - что мы внедряем встраиваемый(Embeddable) класс. ");
        jpa_hibernate.add("// Составной (первичный) ключ, это комбинация из двух или более столбцов для формирования первичного ключа таблицы.\n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n" +
                "- Он мапится с аннотацией @IdClass или @EmbeddedID. \n" +
                "Поля составного ключа описываются в отдельном классе. И в первом варианте мы над классом сущности пишем @IdClass, и имя составного ключа, ну вот указываем класс где описан составной ключ, и внутри сущности объявляем поля. Вот допустим мы оба поля объявляем, и над ними пишем идентификатор т.е. аннотацию @Id.\n" +
                "Это был первый вариант.\n" +
                "\n" +
                "А во втором варианте - класс составного ключа аннотируется @Embeddable. А в классе-сущности над полем класса-ключа пишем @EmbeddedId. \n" +
                "\n" +
                "= А основное отличие какое у них? \n" +
                "- То что, когда мы пишем через @IdClass, то внутри сущности пишем поля, которые являются ключами, ну которые частями ключей являются. \n" +
                "- А во втором случае мы просто объявляем поле, которое имеет тип вот того класса составного ключа. Т.е. у нас появляется только одно поле, а не все поля \n" +
                "IdClassa. // Ну и запросы IdClassa - они проще, но при этом EmbeddableId более информативен, хотя является более сложным. \n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n" +
                "\n" +
                "- У нас есть два способа: 1) - Использовать аннотацию @IdClass и 2) - аннотацию @EmbeddedId.\n" +
                "\n" +
                "- Пример с @IdClass. \n" +
                "\n" +
                "Допустим, у нас есть таблица с именем Account, и она имеет два столбца - accountNumber и accountType, вот они и будут формировать составной ключ. \n" +
                "Чтобы обозначить оба этих поля как части составного ключа мы должны создать класс, например, ComplexKey с этими полями. \n" +
                "Затем нам нужно аннотировать сущность Account аннотацией @IdClass(ComplexKey.class). \n" +
                "И также нужно объявить поля из класса ComplexKey в сущности Account с такими же именами и аннотировать их с помощью @Id.\n" +
                "\n" +
                "public class ComplexKey implements Serializable {\n" +
                "    // Создаем класс, поля которого будут являться частями составного ключа. Делаем его Serializable.\n" +
                "\n" +
                "\tprivate String accountNumber;\n" +
                "                // В этом классе создаем два поля.\n" +
                "\tprivate String accountType;\n" +
                "     \n" +
                "\t// default constructor\n" +
                " \n" +
                "    \n" +
                "\tpublic ComplexKey(String accountNumber, String accountType) {\n" +
                "     // Инициализируем эти поля через конструктор.   \n" +
                "\t\tthis.accountNumber = accountNumber;\n" +
                "        \n" +
                "\t\tthis.accountType = accountType;\n" +
                "     \n" +
                "\t}\n" +
                " \n" +
                "    \n" +
                "\t// equals() and hashCode()\n" +
                "\n" +
                "}\n" +
                "\n" +
                "\n" +
                "\n" +
                "@Entity\n" +
                " \n" +
                "@IdClass(ComplexKey.class)            // Создаем второй класс и помечаем его аннотацией @IdClass(ComplexKey.class)\n" +
                "public class Account {\n" +
                "            \n" +
                "\t@Id\n" +
                "    \n" +
                "\tprivate String accountNumber;\n" +
                "    \n" +
                "\t@Id\n" +
                "    \n" +
                "\tprivate String accountType;\n" +
                "  \n" +
                "  \n" +
                "\t// other fields, getters and setters\n" +
                "\n" +
                "}                                             // Все, у нас теперь есть класс, в котором два поля являются частями составного ключа.\n" +
                "\n" +
                "Пример с @EmbeddedId.\n" +
                "В этом случае класс первичного ключа, BookId, должен быть аннотирован @Embeddable. \n" +
                "\n" +
                "Затем нам нужно встроить этот класс в сущность Book, используя @EmbeddedId.\n" +
                "\n" +
                "@Embeddable\n" +
                " \n" +
                "public class BookId implements Serializable {\n" +
                "    // Создаем Embedable класс, делаем его Serializable.\n" +
                "\n" +
                "\tprivate String title;\n" +
                "                    // Создаем поля, которые будут являться частями составного ключа.\n" +
                "\tprivate String language;\n" +
                " \n" +
                "   \n" +
                "\t// default constructor\n" +
                "    \n" +
                "\n" +
                "\tpublic BookId(String title, String language) {\n" +
                "    // Инициализируем эти поля через конструктор.    \n" +
                "\t\tthis.title = title;\n" +
                "        \n" +
                "\t\tthis.language = language;\n" +
                "    \n" +
                "\t}\n" +
                "  \n" +
                "  \n" +
                "\t// getters, equals() and hashCode() methods\n" +
                "\n" +
                "}\n" +
                "\n" +
                "\n" +
                "@Entity\n" +
                "\n" +
                "public class Book {\n" +
                "                      // Создаем наш Entity-класс.\n" +
                "\t@EmbeddedId\n" +
                "    \n" +
                "\tprivate BookId bookId;\n" +
                "           // Запихиваем в него класс составного ключа. И помечаем это поле аннотацией @EmbeddedID.\n" +
                "    \n" +
                "\t// constructors, other fields, getters and setters\n" +
                "\n" +
                "}");
        jpa_hibernate.add("- Аннотация @Id - определяет первичный ключ, состоящий из одного поля. \n" +
                "- А @GeneratedValue - это аннотация которая определяет каким образом формируется значение ключа.\n" +
                "* Значит, по умолчанию используется значение AUTO. И в таком случае - выбор стратегии зависит от типа базы данных (От ее типа, и диалекта).\n" +
                "* Потом следующий вариант - это IDENTITY. Здесь Id-ключ формируется на стороне БД. \n" +
                "* Потом SEQUENCE - это... в базе данных, ну что-то типа функции есть (SEQUENCE). И она формирует ключ. \n" +
                "* Потом TABLE - это создается в БД специальная таблица, в которой есть колонка, в соответствии с которой генерируется его ключ. \n" +
                "\n" +
                "= А какая разница между SEQUENCE и IDENTITY? \n" +
                "- IDENTITY, я так понимаю что там просто на единицу увеличивается, и все.\n" +
                "- А с помощью SEQUENCE или TABLE - там какие-то вычисления производятся. Ну то есть там, увеличивается не на единицу, а в соответствии с какой-то функцией. \n" +
                "В TABLE - эту функцию задает программист. Т.е. там специальная таблица создается, в которой есть колонка. \n" +
                "Первичный ключ в соответствии с этой колонкой формируется. А в SEQUENCE - я точно там не скажу...\n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n" +
                "- Если мы хотим, чтобы значение первичного ключа генерировалось для нас автоматически, мы можем добавить первичному ключу,\n" +
                "который уже отмечен аннотацией @Id, аннотацию @GeneratedValue.\n" +
                "В параметрах @GeneratedValue мы можем указать одну из 4-рех стратегий:  \n" +
                "AUTO(default) - Указывает, что Hibernate должен выбирает нужную стратегию для конкретной базы данных - автоматически. Смотря какой диалект у БД.\n" +
                "IDENTITY - У него там есть встроенный АВТО-Инкремент, который срабатывает на стороне БД.\n" +
                "SEQUENCE - У него там тоже есть встроенный АВТО-Инкремент на стороне БД.. Но если эта БД не поддерживает тип SEQUENCE, то Hibernate автоматически переключается на тип TABLE. SEQUENCE намного более гибкий, чем IDENTITY.\n" +
                "TABLE - как я понял, хранит ID-шники (для любого количества сущностей) в отдельной таблице. И в этой таблице указываются связи.");
        jpa_hibernate.add("- Аннотация @JoinColumn - указывает на Foreign Key. Т.е эта аннотация содержит столбец с внешним ключом. (А на владельца связи указывает параметр mappedBy).\n" +
                "- А @JoinTable - эта аннотация описывает связующую таблицу в отношениях @ManyToMany. Т.е. 3-я связывающая таблица.\n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n" +
                "- @JoinColumn - указывает что этот столбец FOREIGN KEY, и устанавливает связи между сущностями или коллекциями. \n" +
                "А у нас - кто имеет FOREIGN KEY - тот является владельцем связи. Но также мы можем указать @JoinColumn в обоих таблицах. Тогда оба будут владельцами связи.\n" +
                "И тогда уже, чтобы точно определить владельца связи - нужно указать атрибут mapppedBy (в @ManyToMany и других).\n" +
                "\n" +
                "Примеры: \n" +
                "@OneToOne: - появится столбец в таблице владельца связи, у которого будет внешний ключ.\n" +
                "@OneToMany/@ManyToOne: если у владельца связи не указать атрибут mappedBy, то создается joinTable (отдельная табица) с ключами обеих таблиц. \n" +
                "@JoinTable - создает связывающую (третью) таблицу между двумя другими таблицами. ");
        jpa_hibernate.add("- @OrderBy указывает порядок по которому будут извлекаться элементы коллекций сущностей (базовых или встраиваемых типов) из БД. \n" +
                "Эта аннотация может использоваться с аннотациями @ElementCollection, @OneToMany, @ManyToMany.\n" +
                "\n" +
                "@OrderColumn создает в таблице столбец с индексами для поддержания порядка в списке элементов. \n" +
                "но этот столбец не считается частью состояния сущности или встраиваемого класса. \n" +
                "Hibernate отвечает за поддержание порядка как в базе данных при помощи столбца, так и при получении сущностей и элементов из БД.\n" +
                "\n" +
                "Разница между: @OrderBy vs @OrderColumn.\n" +
                "Порядок, указанный в @OrderBy, применяется только в рантайме при выполнении запроса к БД, То есть в контексте персистентности.\n" +
                "А при использовании @OrderColumn, порядок сохраняется в отдельном столбце таблицы и поддерживается при каждой вставке/обновлении/удалении элементов.\n");
        jpa_hibernate.add("- Эта аннотация используется, для того чтобы пометить поле, которое не нужно мапить в базу данных. \n" +
                "Также по умолчанию транзиентными полями являются final и static - поля.\n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n" +
                "- @Transient используется для объявления того, какие поля у сущности, встраиваемого класса или Mapped SuperClass не будут сохранены в базе данных.\n" +
                "Persistent fields (постоянные поля) - это поля, значения которых будут по умолчанию сохранены в БД. Ими являются любые не static и не final поля. \n" +
                "Transient fields (временные поля):\n" +
                " Поля - помеченные аннотацией @Transient, статические поля и final поля. ");
        jpa_hibernate.add("- Во первых блокировки делятся на две условные группы: оптимистичные и пессимистичные. \n" +
                "* Оптимистичные - это блокировки на уровне сущности (как я понял). По полю @Version. Т.е. если значение поля совпадает со значением в базе данных, то \n" +
                "данные сбрасываются в БД и значение @Version увеличивается на единицу. А если мы начинаем сбрасывать данные, и значение @Version отличается, то тогда будет выброшено исключение. \n" +
                "\n" +
                "Поле версии создается в момент, когда он считывает информацию из БД. И когда он пытается выполнить коммит, он сначала проверяет, как раз этот Version, \n" +
                "если Version не соответствует тому значению которое он имеет в себе, то он - изменения в БД вносить не будет, транзакция выполняться не будет. \n" +
                "Вот это и подразумевает версионность. \n" +
                "\n" +
                "* А пессимистическая блокировка, это блокировка на уровне базы данных. \n" +
                "Когда одна транзакция получила доступ к данным, то доступ для остальных транзакций блокируется.\n" +
                "\n" +
                "Различия оптимистичной и писсимистичной блокировки:  \n" +
                "- Когда у нас в БД обращение к одним и тем же данным, с разных транзакций (параллельных) происходит редко - тогда у нас оптимистическая блокировка применяется (и она быстрее чем пессимистичная). Она работает на уровне JPA. \n" +
                "- А пессимистичная - работает на уровне БД, и включаем мы ее, когда происходит, так сказать, борьба за данные из разных парралельных транзакций. \n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n" +
                "- В порядке от самого ненадежного и быстрого, до самого надежного и медленного:\n" +
                "1. NONE — без блокировки.\n" +
                "2. OPTIMISTIC (синоним READ в JPA 1) — оптимистическая  блокировка. Это значит что: если при завершении транзакции кто-то извне изменит поле @Version, то будет сделан RollBack транзакции и будет выброшено OptimisticLockException. \n" +
                "3. OPTIMISTIC_FORCE_INCREMENT (синоним WRITE в JPA 1) — работает так же как и OPTIMISTIC, но только после каждого commitа значение поле Version принудительно инкрементируется. \n" +
                "4. PESSIMISTIC_READ — данные блокируются в момент чтения и пока выполняется транзакция, никто не сможет их изменить. Остальные транзакции, тем не менее, смогут параллельно читать эти данные. \n" +
                "5. PESSIMISTIC_WRITE — данные блокируются в момент записи и и пока выполняется транзакция, данные в этой транзакции никто не сможет ни читать ни писать.\n" +
                "6. PESSIMISTIC_FORCE_INCREMENT — то же самое что и PESSIMISTIC_WRITE, но в конце транзакции значение поля @Version инкрементируется.\n" +
                " \n" +
                "// Аннотация @Version отвечает за блокировки в JPA. Она решает проблемы, которые могут возникнуть при параллельном выполнении транзакций. \n" +
                "\n" +
                "Если у нас какие-то параллельно выполняющиеся транзакции редко обращаются к одним и тем же данным то можно использовать оптимистическое блокирование. \n" +
                "Но при окончании транзакции будет проверка, изменились ли данные в ходе выполнения этой транзакции и, если да, то выбросится OptimisticLockException.\n" +
                "\n" +
                "Если у нас какие-то параллельно выполняющиеся транзакции очень часто обращаются к одним и тем же данным, и тем самым конкурируют между собой, то тогда лучше использовать пессимистическое блокирование.  Т.е. блокировать доступ к этим данным. \n" +
                "\n" +
                "Блокировки ставятся через метод lock() у EntityManager, в который передаётся сущность, требующая блокировки и уровень блокировки: \n" +
                "\n" +
                "Например: \n" +
                "EntityManager em = entityManagerFactory.createEntityManager(); \n" +
                "\n" +
                "em.lock(company1, LockModeType.OPTIMISTIC); ");
        jpa_hibernate.add("- >>> Кэширование технология (предоставляемая ORM фреймворками), которая помогает достичь высокую скорость. Благодаря кэшированию - в базу данных приходится делать меньше запросов, благодаря чему и обеспечивается высокая скорость. По умолчанию включен кэш первого уровня. \n" +
                "\n"+
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n" +
                "- Кэш первого уровня - он всегда включен, связан с сессией, и сессия видит только свои объекты. При первом запросе, там уходит запрос к базе данных, и данные сохраняются в кэше первого уровня. Все последующие запросы получают данные уже из этого кэша. Кэш первого уровня всегда включен и отключить его мы не можем.\n" +
                "И есть методы для удаления сущностей из кэша и методы для очистки этого кэша. \n" +
                "\n" +
                "- А кэш второго уровня, его работа настраивается, и зависит от провайдера, к которому мы подключены (для управления кэшем второго уровня).\n" +
                "\n" +
                "//Чтобы заработал кэш второго уровня, нужно: \n" +
                "//- Определить провайдера, который реализует работу нашего кэша второго уровня. То есть:\n" +
                "//Перед включением провайдера надо сначала подключить Maven-зависимость, и в конфигурации указать провайдера. Затем нужно, в каком-то классе, реализовать //интерфейс RegionFactory.\n" +
                "//И у нужной сущности указать аннотацию @Cashable, сущность которую нужно кэшировать. \n" +
                "//И прописываем аннотацию @Cache, где указываем детали кэширования. А в деталях прописывается стратегия параллельного доступа, вот что-то я их не вспомню. \n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n" +
                "1. Кэш первого уровня (first-level cache) — кэширует данные только одной транзакции;\n" +
                "2. Кэш второго уровня (second-level cache) — кэширует данные всех транзакций, которые были созданы в какой-то одной фабрики сессий. \n" +
                "// Провайдер JPA может, но не обязан реализовывать работу с кэшем второго уровня.\n" +
                "\n" +
                "// Кэш первого уровня – это кэш сессии (Session), который является обязательным, это и есть PersistenceContext. Через него проходят все запросы.\n" +
                "// Если мы закроем сессию, то все объекты, находящиеся в кэше, теряются. а потом – либо сохраняются в БД, либо обновляются.\n" +
                "\n" +
                "Особенности кэша первого уровня:\n" +
                "- включен по умолчанию, его нельзя отключить;\n" +
                "- связан с сессией (контекстом персистентности). Разные сессии видят только объекты из своего кэша, и не видят объекты, находящиеся в кэшах других сессий;\n" +
                "- при закрытии сессии PersistenceContext очищается - кэшированные объекты, находившиеся в нем, удаляются; \n" +
                "- при первом запросе сущности из БД, она загружается в кэш, связанный с этой сессией; \n" +
                "- если в рамках этой же сессии мы снова запросим эту же сущность из БД, то она будет загружена из кэша, и никакого второго SQL-запроса в БД сделано не будет;\n" +
                "- сущность можно удалить из кэша сессии методом evict(), и тогда, чтобы снова получить эту же сущность, придется опять делать запрос в базу данных;\n" +
                "- метод clear() очищает весь кэш сессии. ");
        jpa_hibernate.add("Чтобы заработал кэш второго уровня, нужно: \n" +
                "- Определить провайдера, который реализует работу нашего кэша второго уровня. То есть:\n" +
                "Перед включением провайдера надо сначала подключить Maven-зависимость, и в конфигурации указать провайдера. Затем нужно, в каком-то классе, реализовать интерфейс RegionFactory.\n" +
                "И у нужной сущности указать аннотацию @Cashable, сущность которую нужно кэшировать. \n" +
                "И прописываем аннотацию @Cache, где указываем детали кэширования. А в деталях прописывается стратегия параллельного доступа, вот что-то я их не вспомню. \n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n" +
                "- Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня.\n" +
                "\n" +
                "Чтобы создать кэш второго уровня - (в Hibernate) кэширование второго уровня нужно настроить RegionFactory (интерфейс). (Кэш 2 уровня разбит на регионы).\n" +
                "RegionFactory это - как мост между Hibernate и поставщиками кэша. \n" +
                "Сам Hibernate не предоставляет кэш, но у него есть другие поставщики. Вот несколько провайдеров: \n" +
                "Поставщиики кэша: Ehcache, OSCache, SwarmCache, JBoss TreeCache. \n" +
                "\n" +
                "В примерах будем использовать Ehcache. Что нужно сделать: \n" +
                "- добавить мавен-зависимость кэш-провайдера нужной версии. \n" +
                "- включить кэш второго уровня и указать провайдера \n" +
                "hibernate.cache.use_second_level_cache=true\n" +
                "; hibernate.cache.ehcache.EhCacheRegionFactory\n" +
                "; \n" +
                "- установить у нужных сущностей JPA-аннотацию @Cacheable, обозначающую, что сущность нужно кэшировать, и Hibernate-аннотацию @Cache. \n" +
                "В качестве параметра, в этих аннотациях нужно указать стратегию параллельного доступа.\n" +
                "\n" +
                "Стратегии параллельного доступа к объектам: \n" +
                "- READ_ONLY: Используется только для сущностей, которые никогда не изменяются (если попытаться изменить эту сущность, будет выброшено исключение).\n" +
                "- NONSTRICT_READ_WRITE: Кэш обновляется после совершения транзакции, которая изменила данные в БД и закоммитила их. \n" +
                "- READ_WRITE: Здесь при обновлении сущности, на нее накладывается мягкая блокировка, которая снимается после коммита транзакци. Все параллельные транзакции, которые пытаются получить доступ к записям в кэше с мягкой блокировкой, не смогут их прочитать или записать и отправят запрос в БД. \n" +
                "Ehcache использует эту стратегию по умолчанию.\n" +
                "- TRANSACTIONAL: Здесь идет разделение транзакций. Каждая сессия и каждая транзакция работают по отдельности, последовательно. \n" +
                "Но при этом падает производительность. ");
        jpa_hibernate.add("- HQL и JPQL - это объектно-ориентированные языки запроса, схожие с SQL. \n" +
                "SQL там - обращение идет к колонкам и выбираются строки, а в HQL и JPQL - там работа идет с сущностями. \n" +
                "И объектно-ориентированные языки запросов, они поддерживают полиморфизм. \n" +
                "JPQL - является подмножеством HQL. \n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  \n" +
                "- Hibernate Query Language (HQL) и Java Persistence Query Language (JPQL) - оба являются объектно-ориентированными языками запросов. \n" +
                "Я так понимаю что: JPQL - относится к JPA, а HQL - относится к Hibernate.\n" +
                "Они немного похожи на SQL. JPQL - является подмножеством HQL.\n" +
                "\n" +
                "JPQL и HQL - они похожи на SQL, только вместо имен и колонок таблиц базы данных, они используют имена классов Entity и их атрибуты. \n" +
                "\n" +
                "В JPQL есть автоматический полиморфизм, и каждый запрос к Entity возвращает не только объекты этого Entity, но и объекты всех его классов-потомков. ");
        jpa_hibernate.add("- Criteria API - это API используемое для выборки данных в объектно-ориентированном стиле. Т.е. это аналог команды Select. \n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n" +
                "- В Hibernate, (начиная с версии 5.2) Hibernate Criteria API объявлен deprecated. \n" +
                "  Вместо него рекомендуется использовать JPA Criteria API. \n" +
                "JPA Criteria API - это такой аналог команды SELECT в SQL, используется для выборки сущностей из БД в объектно-ориентированном стиле. \n" +
                "\n" +
                "Основные преимущества JPA Criteria API: \n" +
                "- ошибки могут быть обнаружены во время компиляции;\n" +
                "- также с помощью него можно запросы можно формировать динамически, на этапе выполнения приложения.\n" +
                "Основные недостатки:\n" +
                "- нет контроля над запросом, и поэтому сложно отловить ошибку в рантайме. \n" +
                "- из-за множества классов, внутри него,\n" +
                " немного падает производительность. \n" +
                "\n" +
                "Области применения Criteria API: \n" +
                "- Использование агрегатных функций вроде sum(), min(), max() и т.д. \n" +
                "- Извлечение данных из выбранных колонок. \n" +
                "- Организация join-запросов, с помощью которых можно соединять несколько таблиц. Для этого есть методы: createAlias(), setFetchMode() и setProjection().\n" +
                "- Сортировку результата выборки, с помощью метода addOrder().");
        jpa_hibernate.add("- Проблема N+1 возникает при получении из базы данных, когда используется N - дополнительных запросов, хотя их можно было получить в одном запросе.\n" +
                "И решается такая проблема несколькими способами:\n" +
                "1. Используется JOIN FETCH, в объектно-ориентированных языках запросов. \n" +
                "2. Через аннотацию @Fetch - задается параметр SUBSELECT - ленивая инициализация. В этом варианте будут два запроса. Первый запрос получит основную сущность, \n" +
                "а второй запрос - все связанные объекты с ней. \n" +
                "3. @BatchSize(size=5)\n" +
                " - он задает количество коллекций которое нужно загрузить. Т. е. если нам нужно получить 6 коллекций, а мы задали @BatcSize = 2, то\n" +
                "то будет сделано 3 запроса. \n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n" +
                "- Проблема N+1 запросов возникает, когда получение данных из БД выполняется за N дополнительных SQL-запросов, хотя эти данные можно было получить одним основным запросом.\n" +
                "\n" +
                "Проблема может быть решена следующими способами:\n" +
                "1. JOIN FETCH. \n" +
                "// И при FetchType.EAGER и при FetchType.LAZY нам поможет JPQL-запрос с JOIN FETCH. Опцию «FETCH» можно использовать в JOIN (INNER JOIN или LEFT JOIN) для // выборки связанных объектов в одном запросе вместо дополнительных запросов для каждого доступа к ленивым полям объекта. \n" +
                "// Лучший вариант решения для простых запросов (1-3 уровня вложенности связанных объектов). \n" +
                "Например пишем JPQL: \n" +
                "select pc\n" +
                " from PostComment pc\n" +
                " join fetch pc.post p.\n" +
                "\n" +
                "2. EntityGraph. \n" +
                "Используется, когда надо получить очень много данных, и у нас jpql запрос. Тогда лучше использовать EntityGraph.\n" +
                "\n" +
                "3. @Fetch(FetchMode.SUBSELECT). \n" +
                "Это такая аннотация Hibernate. Она используется только с коллекциями. Будет сделан только один sql-запрос для получения корневых сущностей. \n" +
                "И по мере необходимости, могут быть выполнены еще запросы, но будут выполнены лениво. \n" +
                "\n" +
                "@Fetch(value = FetchMode.SUBSELECT)\n" +
                "    // Короче я не понял. \n" +
                "\n" +
                "4. Batch fetching. \n" +
                "Это Аннотация Hibernate, в JPA её нет. \n" +
                "Указывается над классом сущности или над полем коллекции с ленивой загрузкой. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций. \n" +
                "Здесь количество загружаемых сущностей указывается в аннотации. \n" +
                "@BatchSize(size=5)\n" +
                "\n" +
                "private Set<Order> orders = new HashSet<>();\n" +
                "\n" +
                "5. HibernateSpecificMapping, SqlResultSetMapping. \n" +
                "\n" +
                "Для нативных запросов рекомендуется использовать именно их.\n" +
                "/////////////////////////////////////////////////////////////\n" +
                "- Для борьбы с проблемой N+1 можно использовать аннотацию @BatchSize(size = 2), поместив ее над полем связанной сущности.\n" +
                "- Можно извлечь все необходимые данные одним SQL-запросом, используя ключ. слово JOIN FETCH.\n" +
                "- Можно использовать FetchType.LAZY вместо FetchType.EAGER. (Помогает не всегда). ");
        jpa_hibernate.add("- Он используется - когда очень много данных. И по сути, в EntityGraf мы можем прописать столбцы, которые нам необходимы в работе. Т.е. мы создаем объект на основании этих графов. Т.е. не весь объект загружаем, а например таблица имеет 20 столбцов, а в работе нам надо только 2 столбца, и мы как раз через EntityGraf указываем эти два столбца. Т.е. указать графы, которые надо загружать. При этом мы можем в качестве графа указать взаимосвязанные сущности, и мы можем ограничить, т.е. например не полностью сущность загружать, а загрузить какую-то определенную информацию этой сущности. \n" +
                "Т.е. допускается частичная загрузка сущности, не полностью от и до, а только то что нам нужнов работе. (и поля сущности мы тоже можем ограничить).\n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n" +
                "- EntityGraph - это такой способ решения проблем с производительностью при загрузке данных из БД, который был введен в JPA 2.1.\n" +
                "Он позволяет выбирать тип графа во время выполнения программы. \n" +
                "Также я где-то читал что, с помощью Entity Graph можно менять стратегию FetchType.EAGER или FetchType.LAZY во время выполнения программы. \n" +
                "Таким образом улучшается производительность в рантайме при загрузке базовых полей сущности, связанных сущностей, и коллекций. \n" +
                "\n" +
                "Т.е. получается - Hibernate загружает весь граф в одном SELECT-запросе. Загружает все указанные связи от нужной нам сущности.");
        jpa_hibernate.add("");
    }

}
