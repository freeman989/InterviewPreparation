package com.answers;

import java.util.ArrayList;
import java.util.List;

public class Algorithms {

    public static List<String> algorithms = new ArrayList<>();

    static {
        algorithms.add(">>> Как я понял: Алгоритмы поиска или сортировки - можно делать либо с помощью циклов, либо с помощью рекурсии.\n" +
                "\n" +
                "- Big O (O большое / символ Ландау)  - это такой символ, который описывает сложность алгоритмов. Это такое математическое обозначение функции для сравнения ее асимптотического поведения, // оно показывает темп роста функции и учитывает не только время, но и количество памяти на выполнение алгоритма.\n" +
                "// Big O - показывает - как будет меняться производительность алгоритма в зависимости от роста входящих данных.   // Так сказал Пузанков. !!!!!!!!!!!!!!!\n" +
                "\n" +
                "// (Big O - дает время выполнения алгоритма при очень больших аргументах(n)). Т.е. - это сложность в худшем случае. // Так сказал Алишев. \n" +
                "\n" +
                "Т.е. - чем больше данных тем больше времени может выполняться какой-то алгоритм, и это время - также будет зависеть от устройства, и операционной системы.\n" +
                "\n" +
                "Основная цель вот этого Big O - это поиск оптимального алгоритма с наименьшим расходом по времени и по памяти.\n" +
                "\n" +
                "Асимптотика - это такой характер изменения функции при стремлении ее аргумента(N) к определённой точке. Т.е. как как именно, будет вести себя функция при прохождении к определенной точке. \n" +
                "// Т.е. линия на графике - это и есть асимптотика - и Big O как раз ее и показывает.!!!!!!!!!!!!!!!!\n" +
                "// Как я понял, Big O - расчитывается не по количеству времени, на выполнение алгоритма, а по количеству операций.\n" +
                "\n" +
                "И любой алгоритм - состоит из неделимых операций (процессора(шагов)), поэтому, вместо секунд, лучше всего измерять время в операциях процессора.\n" +
                " \n" +
                "// DTIME - это количество шагов(операций процессора), необходимых, чтобы алгоритм завершился.\n" +
                "\n" +
                "Временная сложность - она обычно оценивается путём подсчёта числа элементарных операций, которые выполняет алгоритм. !!!!!!!!!!!!!!!!!!\n" +
                "А время исполнения одной такой операции - это константа, то есть асимптотически оценивается как O(1).\n" +
                "  \n" +
                "Сложность алгоритма состоит из двух факторов: временная сложность и сложность по памяти. \n" +
                "Временная сложность - функция, которая показывает зависимость количества операций процессора, от размера входных данных, ну т.е. чтобы алгоритм завершился.\n" +
                "\n" +
                "Все неделимые операции(операции сравнения, арифметические, логические, инициализации и возврата) считаются выполняемыми за 1 операцию процесора. \n" +
                "\n" +
                "(При росте N, слагаемые с меньшей скоростью роста всё меньше влияют на значение функции. Поэтому, вне зависимости от констант при слагаемых, слагаемое с большей скорость роста определяет значение функции. \n" +
                "Данное слагаемое называют порядком функции. Пример: Т(N) = 5 * N^2 + 999 * N... Где (5 * N^2) и (9999 * N) являются слагаемыми функции.) - НЕ ПОНЯЛ.\n" +
                " \n" +
                "(Константы(5 и 999) не указываются в рамках нотации Big O, так как не показывают абсолютную сложность алгоритма, так как могут изменяться в зависимости от машины, поэтому сложность равна О(N^2)) - НЕ ПОНЯЛ.\n" +
                "\n" +
                "Порядок возрастания сложности: \n" +
                "1. O(1) - константная, чтение по индексу из массива. \n" +
                "2. O(log(n)) - логарифмическая, бинарный поиск в отсортированном массиве. \n" +
                "// Где на каждой итерации берется половина элементов - это сложность O(Log n).\n" +
                "3. O(vn) - сублинейная\n" +
                "4. O(n) - линейная, перебор массива в цикле, два цикла подряд, линейный поиск наименьшего или наибольшего элемента в неотсортированном массиве. \n" +
                "5. O(n*log(n)) - квазилинейная, сортировка слиянием, сортировка кучей. \n" +
                "6. O(n^2) - полиномиальная(квадратичная), ВЛОЖЕННЫЕ ЦИКЛЫ, перебор двумерного массива, сортировка пузырьком, сортировка вставками\n" +
                "7. O(2^n) - экспоненциальная, алгоритмы разложения на множители целых чисел\n" +
                ". // Здесь количество операций растет как на дрожжах.\n" +
                "8. O(n!) - факториальная, решение задачи коммивояжёра полным перебором\n" +
                "\n" +
                "Алгоритм считается более таким приемлемым, если сложность не превышает O(n*log(n)), - иначе это будет считаться как говнокод.            +++++");
        algorithms.add("- Рекурсия - это когда какой-то процесс является частью самого себя. Или же, говоря по простому, когда метод вызывает сам себя.\n" +
                "Рекурсия состоит из базового случая и шага рекурсии. Базовый случай - это одна простая задача, которая решается за одну итерацию. \n" +
                "Например: if(n == 0) return 1. \n" +
                "\n" +
                "В базовом случае должно обязательно присутствовать условие выхода из рекурсии; // Иначе получим ошибку: StackOverflow.\n" +
                "\n" +
                "Смысл рекурсии заключается в движении от исходной задачи к базовому случаю. И при этом, на каждом шаге рекурсии, размер исходной задачи уменьшается пошагово. \n" +
                "\n" +
                "После того, как будет найден базовый случай, срабатывает условие выхода из рекурсии, и стек рекурсивных вызовов разворачивается в обратном порядке.\n" +
                " \n" +
                "Пример рекурсивного вычисления факториала: \n" +
                "\n" +
                "int factorial(int n) {\n" +
                "        \n" +
                "\tif(n == 0) return 1;               // базовый случай с условием выхода\n" +
                "        \n" +
                "\telse return n * factorial(n - 1);  // шаг рекурсии (рекурсивный вызов)\n" +
                "    \n" +
                "}\n" +
                ">> Факториал числа - это произведение всех натуральных чисел до него включительно. Или наоборот от него до единицы: 3! = 3*2*1 = 6\n" +
                "\n" +
                "Рекурсия имеет линейную сложность O(n);\n" +
                "\n" +
                "Недостатки рекурсии:\n" +
                "- Циклы дают лучшую производительность, чем рекурсивные вызовы, поскольку вызовы методов потребляют больше ресурсов, чем исполнение обычных операторов. \n" +
                "\n" +
                "- Циклы гарантируют отсутствие переполнения стека, т.к. не требуется выделения доп. памяти. А рекурсионные вызовы занимают много памяти в стэке.\n" +
                "- Но - если уровней вложненности много или они могут изменяться, то лучше использовать рекурсию. А если их несколько, то тогда лучше цикл.\n" +
                "\n" +
                ">>> И кстати, как я понял: Алгоритмы поиска или сортировки - можно делать либо с помощью циклов, либо с помощью рекурсии.                  +++++");
        algorithms.add("- Жадный алгоритм - это одна из 3-х техник создания алгоритмов. \n" +
                "Вот у нас же есть 3 техники алгоритмов:  Разделяй и властвуй, Динамическое программирование и Жадные алгоритмы. \n" +
                "Жадный алгоритм - это такойалгоритм, который на каждом своем шагу совершает как можно лучшее и оптимальное решение, т.е. максимально возможное из допустимых. \n" +
                "И при этом, жадный алгоритм не учитывает - предыдущие или следующие шаги. \n" +
                "\n" +
                "И вот - последовательность этих локально оптимальных шагов (т.е. решений) - обычно приводит к какому-то глобальному оптимальному решению. \n" +
                "Но правда это происходит не всегда, но зато в большинстве случаев.\n" +
                " \n" +
                "Т.е. наша задача рабивается на подзадачи, ииии... в каждой подзадаче принимается оптимальное решение и, в итоге, вся задача решается оптимально.\n" +
                " \n" +
                "При этом нужно учитывать, является ли каждое локальное решение безопасным шагом или нет. \n" +
                "Ну а безопасный шаг - он обычно приводит к оптимальному решению безопасным путем. \n" +
                "\n" +
                "Примеры жадных алгоритмов: \n" +
                "- Есть такой алгоритм Дейкстры. Там есть такой рисунок-схема, состоящий из нескольких точек(вершин), которые расположены друг от друга на разных расстояниях.\n" +
                "И вот этот алгоритм Дейкстры находит кратчайший путь к каждой точке(вершине). Здесь на каждом шаге идет поиск вершины с наименьшим расстоянием(весом), \n" +
                "И в итоге можно будет доказать, что кратчайшие пути, найденные в вершинах, являются оптимальными.\n" +
                "\n" +
                "- Также есть пример с автомобилем, которому нужно проехать много километров, и при этом как можно реже заезжать на заправку, чтоб заправится бензином.\n" +
                "\n" +
                "- И еще один пример: У нас есть несколько куч с золотом разной пробы, и у нас есть всего три мешка, т.е. все золото в наши мешки не поместится.\n" +
                "И благодаря жадному алгоритму, можно расчитать так, - чтобы сначала, в первую очередь наполнять наши мешки золотом высшей пробы, а уже потом более низшей пробы. Потому что все равно все золото в наши мешки не поместится.                                                                 +++++");
        algorithms.add("- Пробегаемся циклом по массиву слева направо. \n" +
                "- Если текущий элемент больше следующего, меняем их местами. \n" +
                "- Делаем так, пока массив не будет отсортирован.\n" +
                " \n" +
                "Короче, я делал так:\n" +
                "\n" +
                "int[] arr = {9,4,6,3,7,2,5,1};                       // Создавал массив и заполнял разными целыми числами.\n" +
                "\n" +
                "        System.out.println(Arrays.toString(arr));\n" +
                "\n" +
                "        boolean f = true;                            // Создавал булевую переменную.\n" +
                "\n" +
                "        while (f){                                   // Которую затем использовал в цикле while в качестве аргумента.\n" +
                "            f = false;\n" +
                "            for(int i = 1; i < arr.length; i++){     // Потом в цикле while создавал еще один цикл for, и в нем перебирал наш массив.\n" +
                "                if(arr[i] < arr[i-1]){               // Сравнивал, с помощью оператора if - текущий элемент со следующим.\n" +
                "                    int temp = arr[i];               // И если текущий элемент больше чем следующий, то менял их местами.\n" +
                "                    arr[i] = arr[i-1];\t\t     // И так до тех пор - пока все не отсортируются.\n" +
                "                    arr[i-1] = temp;\n" +
                "                    f = true;\n" +
                "                }\n" +
                "            }\n" +
                "        }\n" +
                "        System.out.println(Arrays.toString(arr));\n" +
                "\n" +
                "Aсимптотика: в лучшем случае – O(n), в худшем и среднем случае – O(n^2).                                    +++++");
        algorithms.add("- Сначала нужно выбрать некоторый опорный элемент(pivot). //Я так понял желательно в центре: int average = min + (max - min) / 2;\n" +
                "- Затем все элементы перекидываются, меньшие опорного элемента - налево, а большие опорного элемента – направо. \n" +
                "- Для этого используются дополнительные переменные - значения слева и справа, которые сравниваются с pivot. \n" +
                "- Затем с помощью рекурсии в каждой из частей, будет выбран новый pivot - и все шаги повторяются снова. \n" +
                "\n" +
                "// Короче как я понял мы делим наш массив на две части и при этом у нас есть какой-то опорный(центральный) элемент, затем меняем местами: меньшие опорного справа перекидываем налево, а большие опорного слева перекидываем налево. Затем каждую из этих частей тоже делим на две части, и повторяем пройденные шаги. Т.е. массивы разбиваются на подмассивы. И так повторяется до тех пор, пока делить будет нечего. И все это выполняется с помощью рекурсиии.\n" +
                "\n" +
                "В итоге мы получим отсортированный массив, // так как каждый элемент меньше опорного стоял раньше каждого большего опорного. \n" +
                "\n" +
                "Асимптотика:  В лучшем и среднем случае O(n*log(n)). И в худшем случае O(n^2), потому что может произойти неудачный выбор опорного элемента.      +++++");
        algorithms.add("- Основана на парадигме «разделяй и властвуй». \n" +
                "- Сначала дробим массив пополам, пока не получим много массивов из одного элемента. \n" +
                "- После чего делаем слияния: Из первых двух элементов - наименьший элемент кладем влево, наибольший элемент кладем вправо. \n" +
                "- Затем берем два массива из двух элементов и минимальный элемент с лева кладем в новый массив - кладем тоже с левой стороны. \n" +
                "- Затем следующие два массива проделываем все то же самое. \n" +
                "- И так продолжаем делать слияния массивов из 1-го элемента в массивы по 2 элемента, затем из 2-х в 4 и т.д. \n" +
                "- И так до тех пор пока все части подмассивов не сольются в один массив, но уже в отсортированном виде.\n" +
                "\n" +
                "Слияние работает по временной сложности O(n). Количество уровней зависит от log(n). А асимптотика равна O(n*log(n)).             +++++");
        algorithms.add("- Бинарное дерево - это такая иерархическая структура данных, в которой каждый узел является родителем двух других узлов (двух потомков). \n" +
                "Т.е. верхний узел называется родительским узлом, а нижние два (наследники) - они называются левым и правым узлами(нодами). \n" +
                "Самый первый узел, у которого нет родителя - является корнем нашего дерева.\n" +
                "Каждый узел в дереве создает новое поддерево, корнем которого он является. Оба поддерева — левое и правое — тоже являются бинарными деревьями. \n" +
                "// Бинарное дерево - оно потому так и называется, потому что максимум может иметь только двух наследников, и не больше.\n" +
                "Узлы(ноды) - у которых нет потомков, т.е. у которых ссылки на левую и правую часть деревa указывают на NULL - называются листьями такого дерева. \n" +
                "\n" +
                "Каждый узел(нода), в большинстве случаев - он состоит из ячейки с данными, и двух ссылок на следующий левый узел и на следующий правый узел.\n" +
                "\n" +
                "Также бинарное дерево - является упорядоченной структурой данных, т.е. всегда отсортированной. Элементы сортируются сразу при их добавлении.\n" +
                "\n" +
                "И у всех узлов левого поддерева значения элементов(или ключей) меньше, чем значение элемента(или ключа) самого их узла. \n" +
                "И у всех узлов правого поддерева значения элементов(или ключей) больше либо равны, значению элемента(или ключа) самого узла. \n" +
                "\n" +
                "Этим как раз и достигается упорядоченная структура данных.\n" +
                " И поэтому поиск элементов в бинарном дереве происходит очень быстро.\n" +
                "\n" +
                "// Ну короче, в моем понимании бинарное дерево - это просто отсортированный двухсвязный список.\n" +
                "\n" +
                "Поиск в лучшем случае - O(log(n)), худшем - O(n) // - (при вырождении в связанный список).                       +++++");
        algorithms.add("- Красно-черное дерево - Это уже идет усовершенствованная версия бинарного дерева. \n" +
                "В нем - каждый узел имеет дополнительное поле - цвет. \n" +
                "\n" +
                "И у К/ч дерева, есть такие правила:\n" +
                "1) Каждый узел может быть либо черный либо красный.\n" +
                "2) Корень - всегда черный.\n" +
                "3) Все листья, которые не имеют узлов-наследников и не хранят данные - всегда должны быть черные. \n" +
                "4) Оба потомка каждого красного узла - должны быть черными. \n" +
                "5) Каждый путь от узла-предка до самого последнего узла-потомка(листа), - должен содержать одинаковое число черных узлов. \n" +
                "Если вдруг оно становится не одинаковым, то тогда происходит переворот. В этом и заключается самобалансировка К/Ч дерева.\n" +
                "\n" +
                "Потому что, например: При добавлении постоянно увеличивающихся (или уменьшающихся) чисел в бинарное дерево, то там ветка продолжает расти. \n" +
                "И таким образом оно вырождается в связанный список и теряет свои преимущества. \n" +
                "А в к/ч дереве механизм другой:  Здесь левый и правый узлы переворачиваются, и они могут выполнять до двух поворотов. \n" +
                "Поэтому и поддерживается сбалансированность, и вырождение в односвязный список не происходит - как в обычном бинарном дереве. \n" +
                "\n" +
                "При удалении происходит то же самое - узлы также переворачиваются (для соблюдения сбалансированности). \n" +
                "Но только при удалении может произойти до трёх переворотов. Вот в этом то и состоит преимущство к/ч дерева над бинарным деревом. \n" +
                "\n" +
                "Здесь сложность поиска, вставки и удаления, всегда - O(log(n))                                                              +++++");
        algorithms.add("- Линейный поиск - сложность O(n), это когда все элементы проверяются по очереди.  \n" +
                "\n" +
                "- Бинарный поиск - O(log(n)). Двоичный поиск — это алгоритм поиска элемента в отсортированном массиве, который использует дробление массива на половины.\n" +
                "Т.е. массив должен быть отсортирован. Затем происходит поиск в массиве, необходимого элемента, по индексу.\n" +
                "1) Получается, сначала мы сравниваем значение из середины массива со значением, которое мы ищем. Середина расчитывается по формуле: mid = (high + low) / 2\n" +
                "low - это будет индекс начала левого подмассива (а изначально - индекс начала массива), а high - индекс конца правого подмассива (а изначально - индекс начала массива).\n" +
                "2) Если значение в середине больше значения - которое мы ищем, то переходим в левый подмассив и ищем уже там. И делаем вот-так: high = middle - 1\n" +
                "3) Если меньше, то переходим в правый подмассив и тогда поиск продолжается там. И делаем вот-так: low = middle + 1\n" +
                "4) Все это повторяется до тех пор, пока mid не страновится равен искомому элементу, либо подмассив не станет пустым.\n" +
                "\n" +
                "public static int binarySearch(int[] a, int key) {\n" +
                "        \n" +
                "\tint low = 0;\n" +
                "        \n" +
                "\tint high = a.length - 1;\n" +
                "\n" +
                "        \n" +
                "\n" +
                "\twhile (low <= high) {\n" +
                "            \n" +
                "\t\tint mid = (low + high)/2;\n" +
                "\n" +
                " \n" +
                "           \n" +
                "\t\tif (key > a[mid]) {\n" +
                "                \n" +
                "\t\t\tlow = mid + 1;\n" +
                "            \n" +
                "\t\t} else if (key < a[mid]) {\n" +
                "                \n" +
                "\t\t\thigh = mid - 1;\n" +
                "            \n" +
                "\t\t} else return mid;\n" +
                "        \n" +
                "\t}\n" +
                " \n" +
                "       \n" +
                "\treturn -1;\n" +
                "    \n" +
                "}\n" +
                "\n" +
                ">>> Log2(n) - В какую степень нужно возвести 2 чтобы получить N. Или сколько раз нам нужно поделить количество элементов на 2 - чтобы найти нужный элемент.\n" +
                "\n" +
                "// Двоичный поиск работает намного быстрее чем линейный. Функция логарифма растет на графике медленнее чем линейная функция.          +++++");
        algorithms.add("- Stack это - область памяти, т.е. область хранения данных, которая находится в общей оперативной памяти (RAM). // Считается тоже как структура данных.\n" +
                "// Стэк можно сравнить с магазином из пистолета.                                                // Я слышал что в основу входит односвязный список.\n" +
                "Каждый раз, когда вызывается метод, - в памяти стека создается новый так сказать блок-фрейм. \n" +
                "И этот блок-фрейм содержит все локальные переменные метода и ссылки на другие объекты в методе. \n" +
                "И как только метод заканчивает работу, блок-фрейм также перестает использоваться, после чего предоставляется доступ для следующего метода. \n" +
                "\n" +
                "Размер памяти стека намного меньше чем объем памяти в куче(в хипе). Stack работает по принципу - последний зашел, первый вышел (LIFO). \n" +
                "\n" +
                "Queue(интерфейс) - это очередь, которая обычно (но необязательно) работает по принципу - первый зашел, первый вышел (FIFO) - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди. \n" +
                "                  // Я слышал что в основу входит двухсвязный список.\n" +
                "// Но вот у нас есть коллекция PriorityQueue(класс), т.е. очередь с приоритетом, которая нарушает этот принцип (FIFO), потому что использует «natural ordering». Или же использует переданный в нее Comparator при вставке нового элемента. \n" +
                "Потом у нас еще есть Deque(интерфейс) -это такая линейная коллекция, которая расширяет Queue. Она поддерживает вставку и извлечение элементов с обоих концов. \n" +
                "То есть работает и по принципу FIFO, и по принципу LIFO.   // Интерфейс Deque реализует ArrayDeque.   \n" +
                "\n" +
                "И еще: в Queue и Deque методы equals() и hashCode() обычно не переопределяются, как во всех классах унаследованных от Object-а. Они просто используются чтобы\n" +
                "сравнивать ссылки, но не переопределяются.                                                                             +++++");
        algorithms.add("- В большинстве случаев LinkedList проигрывает ArrayList-у. Т.е. ArrayList в большинстве случаев быстрее.\n" +
                "\n" +
                "ArrayList проигрывает: / Т.е. когда лучше использовать LinkedList:  \n" +
                "1. Когда необходимо добавлять много данных в начало или в середину списка.  \n" +
                "2. При удалении элемента с начала (index = 0) списка. \n" +
                "3. .set (вставка элемента с заменой) (в конце списка или в середине списка).  \n" +
                "\n" +
                "LinkedList проигрывает: / Т.е. когда лучше использовать ArrayList: \n" +
                "1. .get (поиск элемента)  // Как говорилось в Ютубе - мы можем получить доступ к любому элементу за константное время.\n" +
                "2. .set (вставка элемента с заменой) (начало и середина) \n" +
                "3. .add (добавление элемента).\n" +
                "4. .remove (удаление элемента) (кроме начала списка).   \n" +
                "\n" +
                "Сравнение сложности:  Индекс   Поиск   Вставка   Удаление  \n" +
                "          ArrayList:  O(1)     O(n)    O(n)      O(n) \n" +
                "         LinkedList:  O(n)     O(n)    O(1)      O(1)                                                                 +++++");
        algorithms.add("");
    }
}
