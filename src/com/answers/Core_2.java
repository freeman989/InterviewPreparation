package com.answers;

import java.util.ArrayList;
import java.util.List;

public class Core_2 {

    public static List<String> core_2 = new ArrayList<>();

    static {
        core_2.add("- Дженерики – это такой набор свойств, с помощью которого можно определять и использовать обобщенные типы. Это когда мы зараннее не знаем какой тип будет указан. Т.е. когда тип указан в виде параметра. Эти параметры можно использовать в классах, интерфейсах и методах. Например мы можем создать какой-то класс, и он будет работать с разными типами данных, хотя при описании класса мы не указывали какой-то конкретный тип. Т.е. , перед созданием объекта какого-то класса или метода, мы как бы, сначала, параметризуем наш объект или метод.\n" +
                "А информация о параметризованном типе доступна только на этапе компиляции и стирается в runtime.");
        core_2.add("- Они нужны для строгой типизации и проверки на этапе компиляции.\n" +
                " Дженерики позволяют передавать тип объекта компилятору в форме <тип>. А компилятор уже может выполнить проверку типов во время компиляции. Также обеспечивается безопасность по приведению типов во время выполнения программы, т.е. строгая тип-я.");
        core_2.add("- Когда мы ничего не указываем в фигурных скобках, это и есть сырой тип ( List list = new ArrayList<>() ). \n" +
                "Нужны для поддержания старого кода (обратная совместимость).\n" +
                "Они использовались как раз до появления дженериков. \n" +
                "И если их не указать, то под капотом используется Object.");
        core_2.add("- Wildcard - в переводе шальная карта, это когда мы можем использовать любой тип, ну или задать ограничения:\n" +
                "“? extends T” - объект, который наследуется от Т, либо сам Т (обычно используется для получения в методе и называется Produsser, так как он отдает) – ковариантность.\n" +
                "“? super T” - любой родитель Т, включая само Т (используется для отдачи в методе и называется Consumer, так как он только отдает)\n" +
                "– контравариантность. \n" +
                "А инвариантность,это когда мы не указываем ни Extends и не Super, а просто <?>. \n" +
                "При использовании ? мы говорим компилятору, чтобы он игнорировал информацию о типе, т.е. <?> - это неограниченный символ подстановки. \n" +
                "<?> означает то же что и <? extends Object>, т.е. принимает всё. // Это можно обойти, создав обобщенный метод, объявленный с переменной типа T.\n" +
                "Короче, Дженерики не дают указывать наследников, если ты указал четкий тип, то он только этот указанный тип и будет пропускать, иначе вылетит эксепшен.\n" +
                "Чтобы это сделать, нужно указать <?>, тогда мы сможем положить туда все что угодно.");
        core_2.add("- Producer Extends Consumer Super. \n" +
                "Wildcard здесь идет как подстановочный знак:\n" +
                " Если мы объявили wildcard с extends, то это producer. Он только «производит», предоставляет элемент из контейнера, а сам ничего не принимает.\n" +
                " А если сделать wildcard с super — то это consumer. Он только принимает, но ничего не предоставляет. \n" +
                "Короче говоря: \n" +
                "Если мы только получаем объекты из дженерик-коллекции - это producer и надо использвовать extends. \n" +
                "Если мы только кладем объекты в коллекцию - это consumer и надо использовать super. \n" +
                "Если мы делаем и то и другое, то не надо использовать ни super, ни extends.");
        core_2.add("- Коллекция - это структура данных, или набор каких-либо объектов. Это как контейнер, который хранит в себе объекты какого-то одного класса. Каждый из этих объектов в коллекции называется элементом. У коллекций намного больше преимуществ чем у обычного массива, но только мы не можем ложить туда примитивы.");
        core_2.add("- Самый первый у нас идет интерфейс Iterable. От него наследуется интерфейс Collection.\n" +
                "Затем от Collection наследуются интерфейсы - List, Set, Queue. \n" +
                "От Listа имплементятся классы - ArrayList, LinkedList, и устаревшие Vector и Stack.\n" +
                "От Set идут - (классы) HashSet, LincedHashSet, TreeSet (При чем Трисет  сначала реализует интерфейс SortedSet).\n" +
                "От Queue идут - интерфейс Deque от которого идет класс ArrayDeque. И еще у нас в этих же ветках идет PriorityQueue.\n" +
                "Потом у нас стоит отдельно интерфейс Map. \n" +
                "От Мэпы идут две ветки:\n" +
                "В первой ветке идет HashMap и LinkedHashMap. И еще устаревший HashTable.\n" +
                "Во второй ветке идет интерфейс SortedMap, от которого идет Treemap.");
        core_2.add("- \"Коллекция (Например List и Set) это - совокупность каких-то элементов (обычно это экземпляры одного класса). А Map - это уже совокупность пар \"\"ключ\"\"-\"\"значение\"\".\n" +
                " И еще у Map нет итерабл, не понятно по чему проводить итерацию.");
        core_2.add("- (Collections это Класс) У Collections для того чтобы работать с коллекциями есть статические методы, \n" +
                "которые реализуют какие-то там алгоритмы (полиморфные) , а вот использование этих алгоритмов позволяет работать с разными видами структур данных. \n" +
                "// Там еще есть методы: sort () - сортирует по порядку; binarySearch () - деление напополам для быстрого поиска; reverse () - сортировка по убыванию; copy();\n" +
                "Ну а Collection - это уже корневой интерфейс Java Collections Framework. Он, в основном применяется там, где требуется высокий уровень абстракции, например, в классе Collections.\n" +
                "В общем, как я понял - у Collection более высокий уровень абстракции чем Collections.\n" +
                "// Методы для фильтра и сортировки в классе Collections.");
        core_2.add("- Поведение с итераторами fail-safe не вызывает никаких исключений при изменении структуры коллекции, потому что работает с её клоном. \n" +
                "// Пример: fail-safe - CopyOnWriteArrayList и итератор keySet коллекции ConcurrentHashMap.\n" +
                "Поведение с итераторами fail-fast, если коллекция меняется во время итерации, выбрасывает исключение ConcurrentModificationException, но зато работает быстрее.\n" +
                " //Пример: fail-fast - Vector и Hashtable. \n" +
                "fail-fast - являются итераторами по умолчанию. ");
        core_2.add("- \n" +
                "Оба интерфейса предназначены для обхода коллекции. \n" +
                "Интерфейс Iterator - у него больше методов для работы с коллекциями и в какой-то версии Java (java-2) заменил Enumeration(interface). Лучше юзать Iterator.\n" +
                "Различия: \n" +
                "с помощью Enumeration нельзя удалять элементы;\n" +
                " - А в Iterator можно, и к тому-же имена методов были исправлены на более читабельные. //(Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);\n" +
                "Enumeration считается устаревшим вместе с классами: Vector/Stack, тогда как Iterator есть во всех современных коллекциях.\n");
        core_2.add("- Iterable интерфейс, Iterator тоже интерфейс, но они связаны между собой.\n" +
                "Интерфейс Iterable имеет метод - iterator(), а тип возвращаемого значения у него - (интерфейс) Iterator.\n" +
                "Объекты классов, которые реализуют интерфейс Iterable, могут использоваться в цикле foreach.\n" +
                "Короче, я проверял, вот этот метод iterator() - он аж оттуда с интерфейса Iterable потягивается в наши коллекции.\n" +
                "Мы можем у самого объекта коллекции вызвать метод iterator() и присвоить его объекту Iterator, затем с помощью hasNext() и next() итерироваться по нашей коллекции, а с помощью remove() удалять их. Соответственно вот-этот for-each использует этот итератор. Кстати, можно и в цикле while тоже использовать.\n" +
                "Цикл for-each можно использовать только при работе с коллекциями имплементирующих интерфейс Iterable.");
        core_2.add("- Можно, но только нужно использовать метод remove(). И это нужно делать после вызова метода next() от Iterator \n" +
                "Иначе при прохождении по ArrayList в цикле for сразу после удаления элемента вылетит эксепшен - ConcurrentModificationException.\n" +
                "// При итерировании через обычный цикл, и если не использовать iterator, у меня выскакивал IndexOutOfBoundsException, но цикл продолжает итерировать и программа не падает.");
        core_2.add("-  Метод remove() удаляет текущий элемент. Только есть один момент, сначала этот элемент необходимо получить с помощью метода next(), если метод remove() вызвать до метода next(), то мы получим IllegalStateException.");
        core_2.add("- Set - имеет беспорядочное множество элементов и без дубликатов(по хешу работает), а List хранит в себе элементы в том же порядке, в каком и были добавлены. \n" +
                "Потом - реализации Setа не добавляют своих новых методов, а используют только унаследованные от Collection.\n" +
                "Также в Sete разрешена только одна ссылка на Null, в отличие от Lista, где можно хранить сколько угодно Nullov.");
        core_2.add("- Интерфейс Set расширяет интерфейс Collection. \n" +
                "Потом он не добавляет новых методов, ну, то есть имеет только методы унаследованные от Collection.\n" +
                "Set - набор уникальных элементов. Среди элем. может присутствовать null, но только один. \n" +
                "Имеет методы: add(), remove(), contans(), iterator().");
        core_2.add("- Класс HashSet - у него порядок добавления элементов будет непредсказуемым - для ускорения выборки элементов используется хэширование.\n" +
                "Класс TreeSet - у него объекты сортируются по возрастанию, потому что применяется к/ч дерево.\n" +
                "Класс LinkedHashSet - он хранит элементы в порядке добавления. Вот как мы добавили, так они и будут извлекаться.");
        core_2.add("- HashSet работает быстрее, чем TreeSet, потому что у TreeSet много времени уходит на сортировку, а у HashSeta по хешам выборка идет бысрее.\n" +
                "В HashSet элементы в случайном порядке, в TreeSet в отсортированном.\n" +
                "HashSet - он обеспечивает постоянную производительность - О(1) - для большинства операций, таких как add () , remove () и contains ().\n" +
                "А TreeSet логарифмическую -  log(n).\n");
        core_2.add("- LinkedHashSet - он может сохранять порядок вставки элементов, а HashSet - не может. \n" +
                "В основе LinkedHashSet лежит LinkedHashMap. \n" +
                "Вот как раз благодаря этому - при обходе коллекции, порядок элементов - идентичен порядку добавления элементов.");
        core_2.add("- Ну также по возрастанию и будет. Он и так сортирует их по возрастанию.\n" +
                "Там хоть как в него элементы не добавляй он все равно их отсортирует по возрастанию, так как в основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать и хранить элементы по возрастанию. \n" +
                "// Через Comparator можно поменять всю эту сортировку.");
        core_2.add("- Все классы, которые реализуют интерфейс Set, они внутренне поддерживаются реализациями Map. Значение, которые мы передаем в HashSet это те же ключи HashMap, только в качестве значения тут используются объекты.\n" +
                "Временная сложность основных операций у HashSet: На поиск, вставку и удаление: Среднее О(1) , Худшее до Java 8: О(n)  , Худшее после Java 8: О(n Logarifm).");
        core_2.add("- В основе LinkedHashSet лежит LinkedHashMap. Здесь тоже получается - порядок элементов при обходе коллекции такой же как и порядок добавления элементов.\n" +
                "Временная сложность LinkedHashSet: На поиск, вставку и удаление: Среднее О(1) , Худшее до Java 8: О(n)  , Худшее после Java 8: О(n Logarifm).");
        core_2.add("- Время для базовых операций - логарифмическое.\n" +
                " Порядок элементов гарантируется, потому-что, в его основе лежит красно-черное дерево, оно умеет само себя балансировать, что как раз и влияет на производительность. Потом у него есть дополнительные методы для упорядоченного списка: first(), last(), headSet(), tailSet().\n" +
                "У него для всех операций идет логарифмическое время, т.е. О(n Logarifm).");
        core_2.add("- List хранит элементы в порядке добавления. Также у него есть несколько методов. Они обеспечивают вставку и удаление элементов в середину списка.\n" +
                "Например метод add() перегружен, можно вставлять элементы как в конец, так и по индексу. remove() - удалять тоже можно по индексу.");
        core_2.add("- ArrayList реализован внутри как обычный массив. Поэтому при вставке элемента в середину, приходится сначала сдвигать все элементы, которые после него, на одну ячейку в право, а уже затем в освободившееся место вставляется новый элемент. \n" +
                "У него там внутри есть автоматический механизм расширения, а вот автоматического «сжатия» нет, но зато его можно выполнить явно, с помощью метода trimToSize() (там было так написано, но что-то я такого метода не видел).\n" +
                "Временная сложность базовых операций у ArrayList: На поиск, вставку и удаление: Среднее О(n) , Худшее О(n). Метод get(index) O(1).\n");
        core_2.add("- Двухсвязный список. Он состоит из элементов одного типа, которые хранят данные и хранят ссылки на следующий и предыдущий элементы. \n" +
                "Временная сложность: для поиска, добавления и удаления из середины списка - O(1) константное [потому что выполняется одна единственная команда для его обнаружения];\n" +
                "А вот на вставку и удаление из середины списка, или получение элемента по индексу уже нужно линейное время O(n) [Например, когда процедура, суммирует все элементы списка, и требует время, которое пропорционально длине списка]. \n" +
                "Позволяет добавлять любые значения, в том числе и null. Для хранения примитивных типов - используются классы-оберки; ");
        core_2.add("- Потому что благодаря этому можно создать двухнаправленную очередь из любых элементов (в том числе и null). Каждый объект, который помещен в этот двусвязанный список, является нодом (узлом). А в каждом узле содержится элемент, и ссылка на предыдущий и следующий узел. Получается двусвязный список (ну или просто связный) состоит из последовательности узлов, каждый из них предназначен для хранения объекта, тип которого был параметризован еще раннее. ");
        core_2.add("- ArrayList это список, реализованный на основе массива, а LinkedList — это двусвязный список, состоящий из нод (из узлов).\n" +
                "Потом LinkedList работает медленнее ArrayListа и потребляет больше памяти. Его лучше применять для вставки/удаления элементов куда-то в середину, или когда нужно гарантированное время добавления элемента в список. ");
        core_2.add("- Queue - переводится как \"очередь\", элементы хранятся в таком порядке, чтобы их было удобнее обработать. Элементы добавляются по принципу FIFO (first-in-first-out) порядке. //Есть своя реализация - PriorityQueue.");
        core_2.add("- Deque - это двухстороняя очередь, расширяет queue. Он отличается от Queue тем, что можно добавлять и удалять элементы как в хвосте так и в голове. \n" +
                "Методов у него больше чем в Queue. Например:\n" +
                " addFirst(E e);\n" +
                " addLast(E e);\n" +
                " И кстати Deque может работать как по принципу FIFO, так и по LIFO.\n" +
                "В Deque, и Queue обычно методы equals() и hashCode() не переопределяются. // а используются методы класса Object, которые сравнивают ссылки.\n");
        core_2.add("- Его реализуют классы: LinkedList,  ArrayDeque.");
        core_2.add("- Интерфейс Queue, и все кто под ним находится.");
        core_2.add("- Ну там идут классы: ArrayDeque и Vector. //Если я не ошибаюсь.");
        core_2.add("- Для x32 систем:\n" +
                "Каждый элемент LinkedList хранит ссылки:\n" +
                "на предыдущий элемент - 4 байта, \n" +
                "следующий элемент - 4 байта, \n" +
                "и ссылку на данные - 4 байта. \n" +
                "Сам объект типа Node (заголовок) занимает приблизительно 8 байт. \n" +
                "Размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. (Округляем до 24)\n" +
                "Примитив типа byte занимает 1 байт памяти, но в списке примитивы упаковываются: объект типа Byte занимает в памяти 16 байт (8 байт на заголовок объекта, 1 байт на поле типа byte и 7 байт для кратности 8). Также напомню, что значения от -128 до 127 кэшируются и для них новые объекты каждый раз не создаются. Таким образом, в x32 JVM 24 байта тратятся на хранение одного элемента в списке и 16 байт - на хранение упакованного объекта типа Byte.\n" +
                "\n" +
                "Для 64-битной JVM каждая ссылка занимает 8 байт, размер заголовка каждого объекта составляет 16 байт (два машинных слова). Вычисления аналогичны. ");
        core_2.add("- ArrayList основан на массиве, для примитивных типов данных сначала идет автоматическая упаковка значения, поэтому 16 байт тратится на хранение упакованного объекта и 4 байта (8 для x64) - на хранение ссылки на объект в самой структуре данных. Получается, в x32 JVM 4 байта используются на хранение одного элемента и 16 байт - на хранение упакованного объекта типа Byte. Для x64 - 8 байт и 24 байта соотвтетсвенно.  х32=20байт х64=32байт.");
        core_2.add("- Map реализуют классы: TreeMap, HashMap, LinkedHashMap, HashTable.");
        core_2.add("- HashMap это обычный массив (а если точнее - ассоциативный массив), каждая ячейка, у этого массива, это бакет. Изначальный размер массива - 16 бакетов.\n" +
                "В каждом бакете хранится либо связанный список, либо, если в одном из бакетов становится болше 8-ми элементов, он (список) может перерождаться в к/ч дерево. Перед тем как положить элемент в корзину, сначала с помощью хеш-кода ключа вычисляется номер самой корзины. Затем, если корзина пустая - элемент сразу кладется в эту корзину, а если не пустая, то происходит прохождение по списку элементов и сравнивание нового элемента (который мы хотим положить в корзину) с каждым элементом в списке. Если хешкоды сравниваемых элементов одинаковые, идет сравнение по методу equalas(). \n" +
                "Вот этот массив (его еще называют Entry[]), хранит в себе ссылки на вот эти списки. //(цепочки) значений.\n" +
                "Каждая нода в этом списке, она представляет из себя Ключ-значение и адрес к следующей ноде. Но если следующая нода отсутствует, то адрес будет равен Null. \n" +
                "Ключи и значения могут быть любых типов, в том числе и null. Потом, если мы хотим добавить в мапу Null, то он пойдет в самый первый бакет.\n" +
                "Затем, у нас есть hashFunction() - она принимает hashCode ключа, а возвращает номер корзины. Потом, когда мы уже определились с корзиной, перед тем как положить элемент в эту корзину, сравнивается - сначала хешкод ноды, и также возможна проверка на equalas(). \n" +
                "Если и хэшкод и equalas равны: идет перезапись\n" +
                ". Если equals не равен: то элемент добавляется в конец списка Hashmap. Также \n" +
                "\n" +
                "HashMap имеет поле loadFactor. Оно может быть задано через конструктор. По умолчанию - 0.75. Его произведение на количество корзин - даст нам необходимое число объектов которое нужно добавить, чтобы состоялось удвоение количества корзин.\n" +
                " Например если у нас мапка с 16-ю(default) корзинами, а loadFactor равняется 0.75, то удвоение корзин произойдет тогда, когда мы добавим 16 * 0.75 = 12 объектов. \n" +
                "После удвоения - все объекты будут перераспределены, с учетом нового количества корзин.\n" +
                "Потом я еще не рассказал: когда у нас количество нод зашкаливает 8, или корзины становятся равными 64, то наш список перерождается в к/ч дерево.\n" +
                "Временная сложность основных операций у HashMap: На поиск, вставку и удаление: Среднее О(1) , Худшее (До Java-8) О(n) , Худшее (После Java-8) О(n логарифм).");
        core_2.add("- LinkedHashMap  - упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, вот как добавили элементы, в таком же порядке будем извлекать. \n" +
                "Это достигается благодаря двунаправленным связям между элементами (также как в LinkedList). Но это преимущество имеет также и недостаток. Недостаток — это увеличение памяти, которое занимет коллекция.\n" +
                "Благодаря тому что основную работу на себя берет родительский класс, серьезных отличий в реализации HashMap и LinkedHashMap не так уж и много.\n" +
                "Временная сложность основных операций у LinkedHashMap такая же как и у HashMap.");
        core_2.add("- Класс TreeMap<K, V> реализован на основе к/ч дерева. Наследуется от класса AbstractMap, реализует интерфейсы NavigableMap и SortedMap. Все объекты в TreeMap сортируются по возрастанию их ключей, все происходит автоматически. (Не так как HashMap, где все идет беспорядочно).\n" +
                "Временная сложность основных операций у TreeMap - логарифмическая.");
        core_2.add("- Он находится в Мэпе. Реализует интерфейс Map, на основе хеш-таблиц. Ключи у него - это объекты WeakReference-класса. Я так понимаю ключи сделаны как слабые ссылки. И - если не существует ни одной ссылки, указывающей на этот ключ, то запись в WeakHashMap будет автоматически удалена. // Примененяется WeakHashMap в реализации обычного кэша. ");
        core_2.add("- Так.. Сначала (по значению hashCode()) вычисляется индекс ячейки массива. Затем в список этой ячейки будет добавлен элемент. Перед тем как добавить, сначала выполнится проверка, ну т.е. - есть ли элементы в этой ячейке или нет. Если элементы с таким hashCode() уже присутствует, но их equals() методы не равны, то элемент будет добавлен в конец списка.\n" +
                "А если вдруг и по equals() тоже равны, то элемент перезаписывается.");
        core_2.add("- В таком случае - объект скорее всего добавится, но обратно мы не сможем его получить.");
        core_2.add("- Да, возможно. Это возможно в случае, если метод, определяющий номер корзины будет возвращать одинаковые значения.");
        core_2.add("- Потому что в этом нет никакого смысла. Ну во первых - метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному методу hashCode() из Objecta. Потом - метод equalas() - тоже не переопределен. И из-за этого мы не сможем отыскать наш элемент. я так понял.\n" +
                "// И еще, потому что - хэш-код массива не зависит от хранимых в нем элементов и вычисление идет по его ссылке. А ссылка маленькая, мы там все равно большую комбинацию Хеша не сможем получить, например как в String.");
        core_2.add("- Да, будет, но тогда в одну корзину будет все попадать. Потому что HashMap потом вырождается в связный список, и... теряет все свои преимущества. ");
        core_2.add("- O(N). Я так понял что, худший случай - это поиск ключа в таблице со списками, а там - перебор ключей занимает линейное время.");
        core_2.add("- O(N) - линейное.");
        core_2.add("- Это интерфейс, который содержит только 1 абстрактный метод. \n" +
                "Может включать сколько угодно default (и static) методов и при этом он остается функциональным //потому что default методы - не абстрактные.");
        core_2.add("- Чтобы точно определить интерфейс что он - функциональный. Она не даст определить второй абстрактный метод в интерфейсе.\n" +
                " (Хотя можно и без нее).");
        core_2.add("- Predicate<T> - имеется функция, которая получает на вход экземпляр класса T и возвращает на выходе значение типа boolean.\n" +
                "Supplier<T> - есть функция, которая ничего не принимает на вход, и на выходе возвращающает результат класса T.\n" +
                "Consumer<T> - имеется функция, которая получает на вход экземпляр класса T, производит с ним какое-то действие и ничего не возвращает.\n" +
                "Function<T,R> - имеется функция, получает на вход экземпляр класса T и возвращает на выходе экземпляр класса R.\n" +
                "UnaryOperator<T> - принимает в параметры объект типа T, выполняет с ним какую-то операцию и возвращает результат этой операций - объект типа T\n" +
                "BinaryOperator<T, Т> - там реализуется функция, она получает на вход - два экземпляра типа T и на выходе возвращающает - экземпляр класса T.");
        core_2.add("- Ссылка на метод (это квадраточие) - это сокращенный синтаксис лямбда - выражения, который выполняет только один метод. Это позволяет нам ссылаться на конструкторы или методы, в каком-то определенном классе.\n" +
                "Например: Consumer<String> consumer = str -> System.out.println(str);\n" +
                "можно переписать по другому, с помощью ссылки на метод: Consumer<String> consumer = System.out::println;\n" +
                "Я так понимаю - вот бывает же - когда мы можем написать и большую лямбда функцию, то тогда лучше использовать ссылку на метод.\n" +
                "Бывают:\n" +
                "Ссылки на статические методы.\n" +
                "Ссылки на нестатические методы (конкретного объекта) \n" +
                "Ссылки на конструкторы - (например: Имя класса::new)");
        core_2.add("- Лямбда-выражение - упрощённая запись анонимного класса, которая как раз может реализовывать функциональный интерфейс. Ее можно заменить, как говорилось выше - ссылкой на метод.");
        core_2.add("- Stream (интерфейс) - это когда идет последовательность элементов, над которой можно производить различные операции.\n" +
                " Операции над стримами бывают или промежуточными или терминальными. Терминальные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом - можно строить цепочки из нескольких операций над одним и тем же стримом. Задача стрима, значит.. - упростить работу с наборами данных, ну.. например - выполняя какие-то операции фильтрации, сортировки, ну.. и другие манипуляции с данными.");
        core_2.add("- Потому что - методы промежуточных операций не будут выполняться, до тех пор - пока не будет вызван терминальный метод.");
        core_2.add("- Стрим из указанных элементов: Stream.of(\"\"1\"\", \"\"2\"\", \"\"3\"\") ,\n" +
                "Стрим из коллекций. Например: List: list.stream()\n" +
                " , Стрим из Map: map.entrySet().stream().\n" +
                "Стрим из массива: Arrays.stream(array)\n" +
                " используется,\n" +
                "Можно сделать из файла - при помощи методов Files.list() и Files.walk()\n" +
                "Можно получить стрим из строки - методом chars(). \n" +
                "Можно также получить стрим с помощью Итерарации какой-то функции\n" +
                "Можно получить стрим из диапазона каких-то чисел. \n" +
                "Можно также получить стрим - конкатенацией других стримов\n" +
                ".\n");
        core_2.add("- Ну, сначала мы создаем саму коллекцию. //Например: Collection<String> collection = Arrays.asList(\"\"a1\"\", \"\"a2\"\", \"\"a3\"\"); \n" +
                "Затем у этой коллекции вызываем метод stream().\n" +
                "//Stream<String> streamFromCollection = collection.stream(); Я так понимаю - нужно вызвать метод stream() у коллекции.");
        core_2.add("- filter(boolean - Predicate) , \n" +
                "map()\n" +
                " , flatMap() ,\n" +
                "limit(n) ,\n" +
                "skip(n) ,\n" +
                "concat(Stream s1, Stream s2) ,\n" +
                " peek(someFunction) , \n" +
                "distinct() , \n" +
                "sorted().");
        core_2.add("- Этот метод существует в основном, для отладки кода, когда мы хотим видеть, как элементы проходят через определенную точку в нашем стриме. \n" +
                "// peek (принимает Consumer). // Например: integerStream.peek(System.out::println). \n");
        core_2.add("- Метод map() делает маппинг, т.е. – преобразование из одного в другое. То есть преобразует объект какого-то типа в объект какого-то другого типа.");
        core_2.add("- flatMap выполняется тогда, когда из одного элемента нужно получить несколько. \n" +
                "Например: \n" +
                "Stream.of(\"H e l l o\", \"w o r l d !\")     \n" +
                ".flatMap((p) -> Arrays.stream(p.split(\" \")))     \n" +
                ".toArray(String[]::new);\n" +
                "Результат: [\"H\", \"e\", \"l\", \"l\", \"o\", \"w\", \"o\", \"r\", \"l\", \"d\", \"!\"] ");
        core_2.add("- map - он преобразует один тип в другой, и для каждого объекта в стриме возвращает по 1 объекту. \n" +
                "flatMap - делает из одного элемента - несколько элементов. //Я так понял.");
        core_2.add("- фильтрует стрим, возвращает только те элементы, которые проходят по критерию (Predicate)\n" +
                ". Проверяет значение на “true” и “false”");
        core_2.add("-  limit(n) - ограничивает наш стрим, сколько мы указали - столько и пройдет дальше по конвееру.");
        core_2.add("-  skip(n) - пропускает первые элементы. То есть, мы можем указать - сколько элементов можно пропустить.");
        core_2.add("-  sorted() - сортирует, т.е. возвращает отсортированный поток.");
        core_2.add("- distinct() - обрабатывает стрим и возвращает его уже без дубликатов. Короче он отсеивает дубликаты.");
        core_2.add("- forEach – принимает consumer, получается он этот стрим возвращает в переданный нами консьюмер (который потребитель). \n" +
                "forEachOrdered – как и forEach, но только он еще и упорядочивает элементы. \n" +
                "count() - подсчитывает все значения\n" +
                "max() - возвращает максимальный элемент\n" +
                "min() - возвращает минимальный элемент\n" +
                "findAny() - как я понял, находит какой-то любой элемент.\n" +
                "anyMatch() - проверяет на наличие совпадения\n" +
                ", т.е. совпадают наши элементы или нет.\n" +
                "allMatch() – (принимает предикат) проверяет - все ли элементы нашего стрима проходят по определенному условию. Возвращает boolean.\n" +
                "findFirst – возвращает первый элемент из стрима.\n" +
                "collect – собирает все элементы в одну коллекцию, которую мы можем указать.\n" +
                "reduce – он там как-то сортирует, применяет бинарный оператор к каждой паре элементов стрима, до тех пор - пока не останется один элемент.\n" +
                "toArray  - возвращет массив.\n" +
                "Потом - все терминальные методы возвращают Optional - чтобы предостеречься от NPE.");
        core_2.add("- collect () - это один из терминальных методов. \n" +
                "Преобразует стрим в коллекцию.");
        core_2.add("- Возвращает какой-то один результат. (от слова \"уменьшить\") \n" +
                " Использует бинарный оператор к каждой паре элементов стрима, пока не останется один элемент.\n");
        core_2.add("- С помощью него мы можем упаковывать стримы в коллекции:\n" +
                "toList() - преобразует стрим в список — List<T>\n" +
                "toSet() - преобразует стрим в список — Set<T>\n" +
                "toMap() - преобразует стрим в список — Map<K, V>\n" +
                "Используются в методе collect().");
        core_2.add("- Для того чтобы сделать (обычный) последовательный поток параллельным, надо вызвать у объекта Stream метод parallel(). Также можно использовать parallelStream() (из интерфейса Collection), чтобы создать параллельный поток из коллекции. Проблема только в том, что он блокирует основной поток.\n" +
                "//Потом, есть такой метод Sequal(), который обратно сливает несколько потоков в один.");
        core_2.add("- Короче, из примитивов, в Java 8 нельзя создавать Streamы напрямую. Но чтобы их все-таки использовать, есть 3 вида Stream-а: IntStream, LongStream, DoubleStream. Они работает быстрее, чем стрим с классами-обертками.\n");
        core_2.add("- Поддержка лямбда-вражений\n" +
                ". Ссылки на методы ::\n" +
                " Функциональные интерфейсы. default методы в интефейсах.\n" +
                "Новое api для работы с датами. Nashorn движок JavaScript (разрабатываемый полностью на Java компанией Oracle). Кодировщик/декодировщик Base 64 кажется.");
        core_2.add("- LocalDate , LocalTime, LocalDateTime, ZonedDateTime, Period. Эти классы, как я понял - автоматически привязываются к локальному часовому поясу.");
        core_2.add("- Optional - такой интересный класс, он позволяет безопасно использовать ссылки на null. Благодаря ему проверки на null можно не делать, и можно не бояться NullPointerException.");
        core_2.add("- Nashorn, какой-то там движок для javascript. Nashorn — немецкое слово (Носорог).");
        core_2.add("- Это такой инструмент, используется в командной строке, для выполнения кода JavaScript в консоли.");
        core_2.add("- Base64.Encoder и Base64.Decoder");
        core_2.add("- Вызвать метод getEncoder() класса Base64.\n" +
                "- Вызвать метод getDecoder() класса Base64.");
        core_2.add("- putIfAbsent() - метод добавляет пару «ключ-значение», если этого ключа там не было;\n" +
                "forEach() - принимает функцию, которая производит операцию над каждым элементом.\n" +
                "compute() создаёт или обновляет текущее значение. \n" +
                "computeIfPresent() - обновляет значение, если ключ существует.\n" +
                "getOrDefault() - возвращает переданное ему значение (по умолчанию), если ключ отсутствует.");
        core_2.add("- LocalDateTime - это объединение LocaleDate и LocalTime, он содержит одновременно и дату и время. \n" +
                "У него есть методы: plusMinutes, plusHours, toSecondOfDay и т.д.");
        core_2.add("- java.time.ZonedDateTime — аналог java.util.Calendar, короче класс-календарь.");
        core_2.add("");
    }

}
