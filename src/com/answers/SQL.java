package com.answers;

import java.util.ArrayList;
import java.util.List;

public class SQL {

    public static List<String> sql = new ArrayList<>();

    static {
        sql.add("- DDL (Data Definition Language) — обозначает - язык определения данных (декларативный метод).\n" +
                "Это такая группа операторов, для работы с таблицами и со структурами этих таблиц. Они описывают - как данные должны храниться в этих таблицах.\n" +
                "То есть все что касается: создание таблицы, удаление таблицы, создание или удаление полей в таблицах, и.т.д. \n" +
                "// Его команды автоматически фиксируются. Поэтому все изменения сразу-же сохраняются в базе данных, и откатить обратно их уже нельзя.\n" +
                "В DDL входят следующие команды: \n" +
                "CREATE – создает: базы данных, таблицы, индексы, процедуры хранения, функции, триггеры, и другие объекты.\n" +
                "ALTER  – изменяет структуру уже существующей базы данных, таблицы, и.т.д.\n" +
                "DROP   – удаляет объекты из базы данных, т.е. таблицы.\n" +
                "TRUNCATE – удаляет все записи из таблицы; // кроме того, удаляются все места, выделенные для записей.");
        sql.add("- (Data Manipulation Language) - группа операторов для манипуляции данными (императивный метод).\n" +
                "Т.е. Это все операции, которые изменяют данные в БД. Например: добавление, получение, изменение и удаление. \n" +
                "Команды DML не фиксируются автоматически. Поэтому изменения не сохраняются сразу и операцию можно откатить (в отличии от DDL). \n" +
                "Только, если мы применим оператор COMMIT, то тогда, помоему можно данные сразу зафиксировать в БД.\n" +
                "Короче DML предназначен для работы с данными в таблицах. В него входят следующие команды:\n" +
                "SELECT - он выбирает данные по каким-то заданным условиям.\n" +
                "INSERT - добавляет новые данные. \n" +
                "UPDATE - изменяет уже существующие данные.\n" +
                "DELETE - удаляет данные при выполнении условия WHERE; Например: DELETE * FROM Имя_таблицы WHERE ID=5; Если удалить без WHERE - то он все удалит.");
        sql.add("- операторы управления транзакциями (Transaction Control Language):\n" +
                "BEGIN     - определяет начало транзакции\n" +
                "COMMIT    - применяет транзакцию (фиксирует). \n" +
                "ROLLBACK  -  откатывает все изменения, сделанные после какой-то транзакции.\n" +
                "SAVEPOINT -  разбивает транзакцию на более мелкие.\n" +
                "// SET TRANSACTION - устанавливает параметры для текущей транзакции.");
        sql.add("- операторы определения доступа к данным (Data Control Language). Отвечают за безопасность:\n" +
                "GRANT   - дает пользователю (или группе пользователей) какие-то разрешения на какие-то определенные операции с объектом.\n" +
                "REVOKE  - отзывает -  ранее выданные разрешения.\n" +
                "DENY    - он вообще запрещает делать какие-то операции с объектом;");
        sql.add("- NULL означает отсутствие данных или неизвестность информации.  \n" +
                "Значение NULL не принадлежит ни одному типу данных. \n" +
                "// Поэтому NULL не равно ни логическому значению FALSE, ни пустой строке, ни 0. \n" +
                "Если сравнить NULL с любым значением, результат будет тоже NULL. Не FALSE и не 0. Более того, NULL не равно NULL. (Так как неизвестно что там лежит).\n" +
                "Проверить поле на NULL можно с помощью команд: IS NULL, IS NOT NULL.");
        sql.add("- JOIN - оператор языка SQL, который выбирает данные из двух таблиц и соединяет эти данные в один результат, т.е. он как бы сцепляет их в одну таблицу. \n" +
                "Например у нас есть таблица с котиками, и в каждой таблице есть имя котика и ID на следующую таблицу. А в той таблице для каждого котика имеется название кошачьего корма. Мы можем соединить эти две тоблицы, так как ID внешнего ключа и первичного ключа могут совпадать.    \n" +
                "Соединение значит, вот-так происходит:\n" +
                "- в какую-то результирующую таблицу входят столбцы обеих исходных таблиц. Они как бы сцепляются между собой, т.е. из двух таблиц получается одна.\n" +
                "- каждая строка таблицы-результата - это результат сцепления двух соединенных строк.       \n" +
                "- если надо соединить не две, а нескольких таблиц, то операция соединения применяется \n" +
                "несколько раз (последовательно). Например: 1-2, 1-3, 1-4, 1-5, и.т.д.\n"+
                "\n"+
                "Какие существуют типы JOIN?\n" +
                "// Outer - означает внешний.\n" +
                "Inner-Join - соединяет только те записи (строки), для которых нашлись пары. Остальные он просто пропускает.\n" +
                "Left-Join  - соединяет все записи с первой таблицы, а для ненайденных записей из второй таблицы проставляет значения Null. \n" +
                "Right-Join - делает наоборот, т.е. соединяет все записи из второй таблицы, а на место нехватающих данных с первой таблицы - подставляет Null.\n" +
                "Outer-Join - Работает, как одновременно левый и правый Joinы, и соединяет все записи из обеих таблиц. Также называется (Full-Join).\n" +
                "Cross-Join - Тоже соединяет обе таблицы. Только там используется - декартово произведение.\n" +
                "Самый простейший пример записи: select * from Имя_первой_таблицы join Имя_второй_таблицы;\n" +
                "\n" +
                "// Разница Join от Union - Join - объединяет таблицы, а Union объединяет запросы."
        );
        sql.add("- Так как JOIN позволяет соединять несколько записей из таблиц одновременно, то лучше использовать его. \n" +
                "Особенно, JOIN лучше всего применять, если нужно выбрать столбцы более чем из одной таблицы.\n" +
                "Да и потом он лучше оптимизируется СУБД, поэтому лучше использовать JOIN.\n" +
                "- Подзапросы же лучше использовать, когда надо вычислять агрегатные значения, т.е. значения каких-то столбцов, для того чтобы их сравнивать между собой.");
        sql.add("- UNION - объединяет результы двух SQL-запросов в одну таблицу. Т.е. делает объединение двух SELECTов.\n" +
                "Например, мы пишем: select Имя_столбца from Имя_таблицы union select Имя_столбца from Имя_таблицы; - И он берет нам все в один столбик запихивает.\n" +
                "Оба запроса должны возвращать одинаковое число столбцов, а типы данных в столбцах должны быть одинаковыми. \n" +
                "Потом - UNION, он не гарантирует порядок записей. И поэтому записи двух запросов могут перемешаться между собой. \n" +
                "А если нужно сделать чтобы все шло по порядку, то можно использовать ORDER BY. (ORDER BY - он как раз сортирует все данные по порядку).\n" +
                "Потом есть еще UNION ALL. И вот разница между ними в том, что UNION отсеивает дубликаты записей, а UNION ALL соединяет все вместе с дубликатами.");
        sql.add("// Агрегатные функции это такие как: SUM, MIN, MAX, AVG, COUNT.\n" +
                "- WHERE - создает условия на ограничения строк. \n" +
                "- HAVING - создает условия на ограничения строк по каким-то агрегатным функциям.\n" +
                "- Отличаются они тем что:\n" +
                "- WHERE нельзя использовать с агрегатными функциями, HAVING можно (предикаты тоже).\n" +
                "\n" +
                "В WHERE использовать алиясы можно всегда, а в HAVING не всегда. Можно, если надо создать псевдоним для результата агрегатной функции. \n" +
                "В WHERE нельзя добавлять какое-то условия для GROUP_BY, а в HAVING можно.\n" +
                "- WHERE используются вместе с операциями SELECT, UPDATE, DELETE.\n" +
                "- HAVING используется только с SELECT (и GROUP BY).");
        sql.add("- ORDER BY - сортирует данные (по умолчанию - по возрастанию). С помощью кл. слов: ASC и DESC можно сделать возрастание или убывание для каждого столбца. ");
        sql.add("- GROUP BY - он распределяет записи по группам, ну смотря какие мы укажем атрибуты. \n" +
                "Он группирует даже по NULL.");
        sql.add("- DISTINCT - выводит в столбце только уникальные значения.");
        sql.add("- Лимитирует, т.е. ограничивает выборку заданным числом.");
        sql.add("- EXISTS - проверяет, существует ли какая-либо запись или нет. Возвращает True или False.");
        sql.add("- • IN - пробегается по списку, и если указанное значение есть, то вытаскивает его. Например: SELECT * FROM Имя_табл. WHERE name IN ('Ivan','Petr','Pavel');\n" +
                "  • BETWEEN определяет диапазон значений. Например между 20 и 25. (Чувствителен к порядку) Пример: \n" +
                "SELECT * FROM Имя_табл. WHERE age BETWEEN 20 AND 25;\n" +
                "• LIKE - работает, в основном с полями VARCHAR (или CHAR). Это - что-то наподобие РЕГУЛЯРНЫХ ВЫРАЖЕНИЙ!\n" +
                "Используется чтобы находить подстроки и замещает любой одиночный символ. Например пишем: \n" +
                "SELECT * FROM Имя_таблицы WHERE NAME LIKE '%а'; (Саша, Даша, Маша..)");
        sql.add("- MERGE - короче, я так понял - он берет одну таблицу, и накладывает ее на другую таблицу. Таким образом происходит слияние этих таблиц. \n" +
                "Если там есть какая-то одинаковая строка - то он просто обновляет ее данные (выполняется UPDATE), а если нет, то он вставляет туда новую строку из первой таблицы (INSERT). ");
        sql.add("- Агрегатных функции - это такие функции, которые получают на вход имя какого-то столбца или столбцов, и делают вычисления со значениями этого столбца (поля).\n" +
                "Например у нас есть таблица с мобильными телефонами и их ценами. И чтобы вычислить среднюю цену, можно применить функцию AVG();\n" +
                "Несколько агрегатных функций:\n" +
                "COUNT - подсчитывает все записи, по условию запроса;\n" +
                "CONCAT - соединяет строки (из указанных столбцов);\n" +
                "SUM - вычисляет сумму всех значений колонки;\n" +
                "AVG - вычисляет среднюю величину всех значений;\n" +
                "MAX - находит максимальное значение из всех выбранных значений;\n" +
                "MIN - находит минимальное значение из всех выбранных значений.\n" +
                "Также есть LOWER, UPPER.");
        sql.add("- Ограничения - это ключевае слова, которые устанавливают правила, для размещения данных в таблице, или в базе. \n" +
                "NOT NULL - указывает, что значения в этой колонке не может быть NULL, т.е. не может быть пустым.\n" +
                "UNIQUE - отсеивает дубликаты. Т.е. не позволяет размещать в колонке повторяющиеся значения.  \n" +
                "PRIMARY KEY - (первичный ключ) это комбинация NOT NULL и UNIQUE. Помечает каждую запись в базе данных уникальным значением.\n" +
                " Например ID.\n" +
                "CHECK - он - проверяет вписывается ли значение в заданный диапазон или нет. ( s_id int CHECK(s_id > 0) )\n" +
                "FOREIGN KEY создает связь между двумя таблицами. Является внешним ключом. FOREIGN KEY в одной таблице указывает на PRIMARY KEY в другой.\n" +
                "DEFAULT устанавливает значение по умолчанию, если никакое значение не предоствлено. (name VARCHAR(20) DEFAULT 'noname').");
        sql.add("- Суррога?тный ключ — это что-то наподобие первичного ключа, только работает немного по другому. \n" +
                "Например: Нам нужно чтобы уникальные значения были строковыми, или символьными. \n" +
                "Здесь - уникальные значения также могут генерироваться автоматически.");
        sql.add("- Индексы - это такие механизмы, которые ускоряют производительность, т.е. позволяют быстрее извлекать записи из таблицы. (Это как страница книги). \n" +
                "Хоть пользователь их не видит, но они там есть.\n" +
                "Индекс - он формируется из значений одного или нескольких записей и указателей на соответствующие записи набора данных.\n" +
                "Когда мы добавляем или удаляем индексы - то мы никак не влияем на сами данные. Они создают структуру для индексируемых полей. \n" +
                "\n"+
                "Есть три типа индексов, а именно:\n" +
                "-Уникальный индекс: этот индекс позволяет полю иметь уникальные значения. Если первичный ключ определен, уникальный индекс применяется автоматически.\n" +
                "-Кластеризованный индекс: сортирует и хранит строки данных в таблицах на основе их ключевых значений. // Это ускоряет операции чтения из БД.\n" +
                "-Некластеризованный индекс: он в отличие от кластерного, не перестраивает структуру набора данных, он просто организуют ссылки на соответствующие записи.\n" +
                "Короче разница в чем: Кластерный индекс упорядочивает данные физически, а не кластерный не упорядочивает данные физически, но все-таки связывает данные логически при помощи ссылок.\n" +
                "Как создать индекс? \n" +
                "Индекс можно создать либо с помощью: CREATE INDEX. Например: \n" +
                "CREATE INDEX имя_индекса ON имя_таблицы(имя_колонки)\n" +
                "либо при создании таблицы, когда мы создаем первичный ключ и указываем UNIQUE то это тоже считается индексом.");
        sql.add("- DELETE - оператор DML, удаляет записи из таблицы. (которые удовлетворяют условиям WHERE). Медленнее, чем TRUNCATE. Есть возможность восстановить данные.\n" +
                "- TRUNCATE - DDL оператор, удаляет все строки из таблицы. Нет возможности восстановить данные - сделать ROLLBACK.\n");
        sql.add("- Хранимая процедура — такой же метод как и в обычном ЯП, и она хранится на сервере. \n" +
                "В хранимых процедурах могут выполняться обычные операции с базами данных (как DDL, так и DML). \n" +
                "Они повышают производительность, и обеспечивают безопасность данных. Также они расширяют кое-какие возможности программирования.\n" +
                "В большинстве СУБД, хранимые процедуры находятся в скомпилированном виде, благодаря чему обработка данных происходит быстрее.\n");
        sql.add("- View - это такая виртуальная таблица, которая представляет данные таблиц каким-то альтернативным образом. Т.е. как-то по другому.\n" +
                "Т.е. можно из двух таблиц слепить одну таблицу, или можно сделать так, чтобы таблица выводила только те столбцы - которые нужны, а которые не нужны скрыть. \n" +
                "Вот эти виртуальные таблицы (View), они не содержат никаких собственных данных. Таким образом расширяются возможности управления данными. \n" +
                "Представления можно создавать как из таблиц, так и из других созданных представлений, т.е. они могут быть вложенными (до 32 уровней вложенности).");
        sql.add("- Временные таблицы - это как черновик. Например мы можем сделать выборку данных из нескольких таблиц, поработать с этими данными какое-то время и затем удалить эту временную таблицу.\n" +
                "Чтоб создать временную таблицу, нужно использовать один знак решетки # или два знака решетки ##. \n" +
                "Если используется один знак #, то создается локальная таблица, она доступна в течение текущей сессии. \n" +
                "Ели используются два знака ##, то создается глобальная временная таблица. \n" +
                "Глобальная временная таблица доступна для всех открытых сессий, а локальная только для текущей.\n" +
                "Пример: CREATE TABLE #Имя_таблицы\n" +
                "(Id INT, \n" +
                "Name VARCHAR(20));\n" +
                "Срок жизни временной таблицы – это сеанс с БД.");
        sql.add("- Транзакция - это выполнение нескольких операций за один шаг. Несколько операций - как одно целое. При этом целостность структуры данных не нарушается. \n" +
                "Т.е. когда мы выполняем несколько действий (т.е. транзакцию). И если хоть одно действие не будет выполнено, то и все остальные не будут выполнены.\n" +
                "Принципы ACID для транзакций:\n" +
                "• Атомарность (atomicity) - Гарантирует что транзакция будет выполнена полностью, либо не будет выполнена совсем. Без промежуточных состояний.\n" +
                "• Согласованность (consistency). - Означает что - транзакция, которая успешно выполнилась - фиксируется и сохраняется в базе данных.\n" +
                "• Изолированность (isolation). - Означает что - во время выполнения транзакции, параллельные транзакции не должны влезать в ее работу.\n" +
                " Т.е. каждая транзакция независима и изолирована.\n" +
                "• Долговечность (durability). - Какие-бы проблемы не произошли (Например: потеря питания, сбой или ошибки любого рода) - если транзакция успела завершиться, то при возобновлении работы системы - все будет также сохранено. А если нет, то все также и останется, а данные при этом не будут повреждены.\n" +
                "(Надежность) Если пользователь получил от системы уведомление что транзакция выполнена, то он может быть уверен - что изменения не будут отменены.");
        sql.add("// Во первых есть такое понятие - как \"Грязное чтение данных\". Это означает, что когда мы читаем данные во время выполнения какой-то другой транзакции, мы\n" +
                "можем прочитать какой-то один результат, а после завершения той транзакции - результат может быть совершеннно другим. \n" +
                "// \"Неповторяющееся чтение\" - это когда при повторном чтении, пока транзакция не завершилась - прочитанные данные могут оказаться измененными;\n" +
                "// \"Фантомное чтение\" - это когда одна транзакция несколько раз выбирает какие-то записи, и по одним и тем же критериям. \n" +
                "А другая транзакция в то же время проделывает с этими записями какие-то операции. \n" +
                "\n"+
                "• Чтение неподтверждённых данных (read uncommitted) — чтение каких-то незафиксированных изменений во время транзакции. \n" +
                "Нет гарантии, что при таком чтении (его еще называют грязное чтение), данные не будут изменены после завершения транзакции. \n" +
                "(Пример с яблоками).\n" +
                "• Чтение подтвержденных данных (read committed) — чтение всех изменений, уже после выполнения транзакций.\n" +
                "• Повторяемость чтения (repeatable read) — Уровень, позволяющий читать данные повторно. Т.е. чтение всех изменений транзакции. \n" +
                "Данные обновились, и он еще раз их может считать.\n" +
                "• Упорядочиваемость (serializable) — это означает, что пока не будет выполнена одна транзакция, другие транзакции не будут выполняться. Т.е. они как бы выполняются в последовательном порядке. Таким образом транзакции изолированы друг от друга еще лучше, чтобы не мешать друг другу.\n" +
                "- Уровни изолированности транзакций идут в порядке увеличения. Соответственно, надежность работы с данными также увеличивается.\n");
        sql.add("// Нормализация - это процесс приведения в нормальные формы.\n" +
                "- Нормализация - разбиение таблиц на более мелкие, благодаря чему избыточные данные удаляются. (Таким образом данные не дублируются).\n" +
                "- Денормализация - обратный процесс. Это делается для повышения производительности и скорости извлечения данных. \n" +
                "Существуют несколько типов нормальных форм, вот три из них:\n" +
                "- Первая нормальная форма - это когда значения всех полей атомарны (т.е. неделимы).\n" +
                "- Вторая нормальная форма - это когда все неключевые поля целиком зависят от какого-то одного ключа. Например, когда мы не можем удалить таблицу, так как от нее зависит другая таблица, т.е. ее ключи привязаны к той первой таблице.\n" +
                "- Третья нормальная форма - все неключевые поля не зависят друг от друга. \n" +
                "Также есть нормальная форма Бойса-Кодда - Но я, короче о ней ничего не знаю. (Каждая ее нетривиальная и неприводимая форма находится слева).\n" +
                "- И еще каждая нормальная форма включает в себя предыдущую. ");
        sql.add("- TIMESTAMP - это специальный тип данных в SQL, который расширяет возможности типа данных DATE.  \n" +
                "Он хранит в себе секунды с 1 января 1970 года (по Гринвичу). Тогда была создана Unix. У TIMESTAMPа очень высокая точность по сравнению с DATETIME.\n" +
                "TIMESTAMP можно как-то преобразовать в DATE и в DATETIME. (Вроде-бы с помощью функции Cast()).\n" +
                "Данные TIMESTAMPа отображаются с учётом часового пояса. Размер: 4 байта.\n" +
                "(DATETIME предназначен для хранения целого числа: YYYYMMDDHHMMSS. И это время не зависит от временной зоны настроенной на сервере. Размер: 8 байт)");
        sql.add("");
    }
}
