package com.answers;

import java.util.ArrayList;
import java.util.List;

public class Spring {

    public static List<String> spring = new ArrayList<>();

    static {
        spring.add("- Inversion of Control - это такой подход ООП, который позволяет передать контроль над созданием и управлением объектами (в Java) другому фреймворку, например Spring-у. Этот механизм Inversion of Control работает с помощью рефлексии. \n" +
                "Вместо ручного создания объектов и управление ими, и внедрения зависимостей в эти объекты, можно все это дело передать фреймворку. \n" +
                "А он уже возьмет на себя всю \n" +
                "ответственность за создание и управление этими объектами (благодаря Inversion of Control-контейнеру). \n" +
                "Контейнер (или по другому, контекст) отвечает за управление жизненным циклом объекта: т.е. - создание объектов, вызов методов инициализации и \n" +
                "связывания этих объектов  между собой. \n" +
                "Объекты, создаваемые контейнером, называются БИНами. Конфигурирация контейнера с этими бинами осуществляется с помощью аннотаций (это современный способ), но также можно конфигурировать контейнер с помощью XML-файлов (это уже по старинке).\n" +
                "\n" +
                "- Dependency Injection — это одна из реализации принципа Inversion of Control (в Spring). Это такой шаблон проектирования, в котором контейнер внедряет одни \n" +
                "объекты в другие объекты. Он может внедрять: при помощи конструктора или метода-setter-а. И это позволяет снизить связанность между компонентами, т.е. объектами, а так же повысить модульность и расширяемость ПО. +++++");
        spring.add("- Inversion of Control Container (в Spring-е) - это такой контейнер, его еще называют контекст. \n" +
                "Он отвечает за создание, настройку и сборку объектов, которые называются БИНы, а также отвечает за управление этими бинами и их жизненным циклом. \n" +
                "Чтобы создать контейнер Spring - нужно создать объект контейнера на основе интерфейса ApplicationContext и его классов, которые его реализуют.\n" +
                "Существует несколько реализаций интерфейса ApplicationContext: \n" +
                "? ClassPathXmlApplicationContext и FileSystemXmlApplicationContext - это для автономных приложений. (Здесь используются файлы XML); \n" +
                "-- FileSystemXMLApplicationContext - здесь контекст загружается из файла.\n" +
                "-- ClassPathXmlApplicationContext - здесь контекст загружается из пути компьютера. Можно несколько файлов конфигурации указывать через запятую.\n" +
                "? WebApplicationContext - это идет для веб-приложений; \n" +
                "? AnnotationConfigApplicationContext - здесь конфигурация происходит с помощью аннотаций. И в конструктор нужно передать либо пакет - где находится конфигурационный класс, помеченный аннотацией @Configuration, либо сам этот конфигурационный класс.\n" +
                " \n" +
                "Получается, - Spring-контейнер читает все записи конфигурационного класса и все другие аннотации, \n" +
                "ну т.е. получает инструкции о том, какие объекты нужно создавать и настраивать. А эти все конфигурации могут быть представлены в \n" +
                "виде XML-файла, Java-аннотаций или Java-кода: \n" +
                "\n" +
                "? XML - Метаданные считываются из файла с расширением *.xml; \n" +
                "? Java-аннотации - это когда метаданные конфигурации считываются на основе аннотаций. Но также есть один XML-файл с базовыми настройками. \n" +
                "Аннотации могут использоваться в классах, методах и полях.  \n" +
                "Контейнер сначала читает аннотации, а уже потом файл-XML, поэтому, если бин конфигурируется и через аннотации и через XML-файл, \n" +
                "то настройки XML в итоге переопределят настройки аннотаций. \n" +
                "? Java-код - Здесь используется чисто Java-код и аннотации. Файлов XML тут нет вообще. А настройки определяются в специальном классе, помеченном аннотацией @Configuration. (Java-код с аннотациями появились - начиная со Spring 3.0). +++++");
        spring.add("- Бины - это объекты, созданные и управляемые контейнером Spring. Это такой же обычный объект ООП, но только он был создан Spring-ом и находится в его контексте (или контейнере). \n" +
                "// Бины и их зависимости обычно прописываются в конфигурации, или же могут быть помечены аннотацией @Component. +++++ ");
        spring.add("- Аннотация @Bean указывает на метод, который создает, настраивает и инициализирует новый объект, т.е. бин, который находится в контейнере и управляется им. \n" +
                "Эти методы можно использовать в классах с аннотацией @Configuration, а также можно и в классах с аннотацией @Component(или её наследниках). //Проверено мной.\n" +
                "\n" +
                "// Классы, аннотированные @Configuration, проксируются через CGLIB. Классы @Component или обычные классы не проксируются.\n" +
                "\n" +
                "@Bean(\"nameGibbon\")\n" +
                "public Gibbon beanGibbon(){\n" +
                "\tSystem.out.println(\"Bean created from MyConfig-class\");\n" +
                "        return new Gibbon();\n" +
                "}\n" +
                " \n" +
                "По умолчанию именем бина будет являться имя метода, а если мы захотим задать другое имя для бина (т.е. создать алияс) - то его можно указать в параметрах \n" +
                "аннотации @Bean(\"name\").   +++++");
        spring.add("- @Component - указывает на класс из которого Spring будет создавать бины.    +++++");
        spring.add("- @Bean - ставится над методом который создает бины из классов, которые могут находиться в какой-нибудь сторонней библиотеке (ну или же написанные нами),  \n" +
                "а @Component используется для указания класса, чтобы создавать бины, но эти классы могут быть написаны только программистом.     +++++");
        spring.add("- @Service - указывает, что класс является сервисом для реализации бизнес-логики.\n" +
                " Т.е. в этих классах прописывается какая-то бизнес-логика.\n" +
                "@Repository, @Service, @Controller и @Configuration - это алиасы(псевдонимы) @Component, т.е. эти аннотации имеют ту же функциональность что и @Component. \n" +
                "Технически они одинаковы, но только у них разные названия, и используются для разных целей. \n" +
                "\n" +
                "@Repository - указывает, что этот класс используется для работы с поиском, получением или хранением данных. \n" +
                "Также эта анннотация может включать в себя все реализации шаблона DАО (Data Access Object (Объект доступа к данным)). \n" +
                "// DAO - инкапсулирует всю логику работы с БД, а @Repository больше приближен к домену.\n" +
                "\n" +
                "Также в задачу @Repository входит отлов определенных исключений персистентности и проброс их дальше, как непроверенное исключение. \n" +
                "Но для этого - в контейнере должен быть класс PersistenceExceptionTranslationPostProcessor.      +++++");
        spring.add("- @Autowired – внедряет подходящий бин автоматически. Происходит это следующим образом: \n" +
                "1) В первую очередь контейнер определяет тип объекта для внедрения. \n" +
                "2) Затем контейнер подыскивает у себя внутри соответствующий тип бина. \n" +
                "3) Если есть несколько кандидатов, и один из них помечен как @Primary, то внедряется он. //Аннотация @Primary задает бин, который будет внедрен по умолчанию. \n" +
                "4) Если используется @Qualifier, то контейнер будет использовать информацию из @Qualifier, чтобы понять, какой именно компонент внедрять\n" +
                "5) А иначе контейнер внедрит бин, основываясь на его имени или ID. (Например @Component(\"name\")).\n" +
                "6) Если ни один из способов не сработал, то будет выброшено исключение. \n" +
                " \n" +
                "И еще в аннотации есть один параметр required(требуется) = true/false - который указывает, обязательно ли делать DI или нет. По умолчанию true. \n" +
                "Если мы не хотим чтобы было выброшено исключение, то внедряемое поле можно оставить c null, или прописать условие: \n" +
                "если нужный бин не был найден - false.\n" +
                "\n" +
                "// Потом - при циклической зависимости, когда объекты ссылаются друг на друга, аннотацию @Autowired ставить над конструктором нельзя.\n" +
                "\n" +
                "// Потом - контейнер внедряет зависимость с помощью класса AutowiredAnnotationBeanPostProcessor.    +++++");
        spring.add("- Аннотация @Resource позволяет внедрять ресурсы. Она применяется к классам, полям или методам.  // Также как и @Autowired, но разница все-таки есть.\n" +
                "Перед тем как внедрить какую-то зависимость (т.е. ресурс), она сначала ищет его по имени, затем ищет по типу, затем по описанию (Qualifier).\n" +
                " \n" +
                "Имя ресурса берется из имени метода(сеттера) или поля, который мы пометили этой аннотацией, или имя берется из параметра аннотации @Resourse. \n" +
                "А при аннотировании классов - имя должно быть указано явно. \n" +
                "Когда мы указываем эту аннотацию у полей или методов, с аргументом \"name\", в контейнере будет выполнен поиск бинов с таким-же именем, и в контейнере должен быть бин с таким именем: \n" +
                "  \n" +
                "@Resource(name=\"namedFile\") \n" +
                "private File defaultFile;  \n" +
                "  \n" +
                "Если указать аннотацию @Resource без аргументов, то Spring будет искать бин по его типу. Если в контейнере находится несколько бинов-кандидатов на внедрение, то нужно использовать аннотацию @Qualifier: \n" +
                "\n" +
                "@Resource \n" +
                "@Qualifier(\"file_1\") \n" +
                "private File dependency1;   \n" +
                "\n" +
                "@Resource \n" +
                "@Qualifier(\"file_2\") \n" +
                "private File dependency2; \n" +
                "\n" +
                "Разница с @Autowired:\n" +
                "\n" +
                "? Аннотация @Resource ищет бин сначала по имени, а потом по типу;\n" +
                " (а @Autowired сначала ищет по типу).\n" +
                "? Аннотации @Resource не нужна дополнительная аннотация для указания имени конкретного бина;\n" +
                " (потому что у @Autowired, чтобы указать имя, приходится делать так @Qualifie(name)\n" +
                "? Потом аннотация @Autowired позволяет указать, что бин внедрять необязательно @Autowired(required = false);\n" +
                " (а у @Resource такого нет).\n" +
                "? при замене Spring-а на другой фреймворк, менять аннотацию @Resource не нужно. (т.е. другие популярные фреймворки тоже используют эту аннотацию).   +++++");
        spring.add("- @Inject - это аннотация Java, является аналогом @Autowired в Spring-е. Она внедряет зависимости, в первую очередь по типу, затем по описанию и только потом по имени. В ней нет параметров. \n" +
                "И поэтому при использовании конкретного имени (Id) бина используем дополнительную аннотацию @Named. Например пишем:\n" +
                "\n" +
                "\n" +
                "@Inject\n" +
                "\n" +
                "@Named(\"variable\")\n" +
                "\n" +
                "private Animal variable;    \n" +
                "\n" +
                "@Inject не относится к Spring-у, и входит в пакет javax.inject. А чтобы её использовать, надо добавить Maven-зависимость:\n" +
                "\n" +
                "<dependency>\n" +
                "   \n" +
                "\t<groupId>javax.inject</groupId>\n" +
                "   \n" +
                "\t<artifactId>javax.inject</artifactId>\n" +
                "   \n" +
                "\t<version>1</version>\n" +
                "\n" +
                "</dependency>\n" +
                "\n" +
                "                                      +++++");
        spring.add("- Аннотация @Lookup(поиск) - используется, как я понял, когда у объекта синглтон, каждый раз меняется внедряемый объект, который может быть Prototype.\n" +
                "Например: \n" +
                "У нас есть бин Car(автомобиль) – и он синглтон, и ему каждый раз требуется новый экземпляр бина Passenger(пассажир). \n" +
                "То есть Car – синглтон, а Passenger – так называемый \n" +
                "прототипный бин. \n" +
                "И жизненные циклы у этих бинов разные. \n" +
                "Бин Car создается контейнером только один раз, а бин Passenger создается каждый раз новый. \n" +
                "Например это происходит каждый раз при вызове какого-то метода \n" +
                "бина Car. Вот здесь то и пригодится внедрение бина с помощью Lookup метода. \n" +
                "\n" +
                "Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод. \n" +
                "Можно создать метод-заглушку в бине Car и пометить его – аннотацией @Lookup. \n" +
                "\n" +
                "И этот метод должен возвращать бин Passenger, каждый раз новый.  \n" +
                "\n" +
                "Даже если в вашей заглушке он возвращает null (а так и надо делать, все равно этот метод будет переопределен).\n" +
                "\n" +
                "Пример: \n" +
                "\n" +
                "@Component \n" +
                "public class Car {    \n" +
                "\t@Lookup    \n" +
                "\tpublic Passenger createPassenger() {\n" +
                "\t        return null;    \n" +
                "\t}    \n" +
                "\tpublic String drive(String name) {        \n" +
                "\t\tPassenger passenger = createPassenger();        \n" +
                "\t\tpassenger.setName(name);        \n" +
                "\t\treturn \"car with \" + passenger.getName();    \n" +
                "\t}\n" +
                "}                                                           +++++");
        spring.add("- Напрямую нельзя. Потому что Spring не позволяет внедрять бины напрямую в статические поля. \n" +
                "Потому что - загрузчик классов загружает статические значения раньще чем, Spring загрузит бины в контекст.\n" +
                " \n" +
                "Но это можно исправить. Для этого можно создать нестатический сеттер-метод, и пометить его аннотацией @Autowired:\n" +
                "\n" +
                "private static Item item;\n" +
                "\n" +
                "   \n" +
                "\n" +
                "@Autowired\n" +
                "   \n" +
                "public void setItem(Item item) {\n" +
                "       \n" +
                "\tTestDataInit.item = item;\n" +
                "   // Получается просто внедряем статическое в нестатическое.\n" +
                "}                                                                                                +++++");
        spring.add("- @Qualifier применяется если кандидатов для автоматического связывания несколько. В ее параметрах мы можем указать имя конкретного бина, \n" +
                "который мы собираемся внедрить. Эта аннотация может быть применена к отдельному полю класса, к отдельному аргументу метода или конструктора. Например:\n" +
                "\n" +
                "public class AutowiredClass {\n" +
                "\n" +
                "    \n" +
                "\t@Autowired //к полям класса\n" +
                "    \n" +
                "\t@Qualifier(\"dog\")\n" +
                "    \n" +
                "\tprivate Animal animal;\n" +
                "\n" +
                "    \n" +
                "\n" +
                "\t@Autowired //к отдельному аргументу конструктора или метода\n" +
                "    \n" +
                "\tpublic void voice(@Qualifier(\"dog\") Animal animal){\n" +
                "        \n" +
                "\t\t/* что-то делаем... */\n" +
                "    \n" +
                "\t};\n" +
                "\n" +
                "}\n" +
                "\n" +
                "@Primary тоже используется для автоматического внедрения, когда есть несколько бинов одного типа, но только в ней нельзя задать имя бина, \n" +
                "и она определяет значение \n" +
                "по умолчанию. Получается что @Qualifier более специфичен.\n" +
                "\n" +
                "Если стоят обе эти аннотации, и @Qualifier и @Primary, то аннотация @Qualifier - идет по ПРИОРИТЕТУ выше.      +++++");
        spring.add("- Чтобы заинжектить примитив, надо использовать аннотацию @Value. Ее можно ставить над полем, конструктором или методом. \n" +
                "Значения этих примитивов можно указывать напрямую, а можно получать из property файлов, или из view, или из других бинов, и т.п. \n" +
                "Если значения будут указываться из Property-файлов, то нужно указать аннотацию @PropertySource, перед классом конфигурации. \n" +
                "Пример: @PropertySource(\"classpath:values.properties\")\n" +
                "\n" +
                "Пример из файла:\n" +
                "@Value(\"${some.key}\")\n" +
                "\n" +
                "public String stringValue;\n" +
                "\n" +
                "В эту переменную будет внедрена строка, например из property или из view. \n" +
                "// Кроме того, для внедрения значений мы можем использовать язык SpEL (Spring Expression Language). Ну про него я ничего не могу сказать...     +++++");
        spring.add("- Да также как и обычный объект. Можно заинжектить с помощью аннотации @Autowired. Можно заинжектить: массив, коллекцию, или map-у с дженериком, или другие бины подходящие по типу. \n" +
                "В случае с map ключом будет имя бина.\n" +
                "Пример: \n" +
                "\n" +
                "@Autowired\n" +
                "@Qualifier(\"action\")\n" +
                "List<Hero> actionHeroes;\n" +
                "\n" +
                "Или в конфигурационном классе, с помощью аннотации @Bean.\n" +
                "@Bean\n" +
                "    public ArrayList<Hero> action() {\n" +
                "        ArrayList<Hero> result = new ArrayList<>();\n" +
                "        result.add(new Terminator());\n" +
                "        result.add(new Rambo());\n" +
                "        return result;\n" +
                "    }\n" +
                " \n" +
                "\n" +
                "Используя аннотацию @Qualifier можно настроить тип необходимого бина.\n" +
                " \n" +
                "\n" +
                "Также бины можно упорядочить с помощью аннотации @Order (если, например у нас идут какие-то неупорядоченные коллекции, вроде Set или Map).      +++++");
        spring.add("- Аннотация @Conditional - она поддерживает настройки компонентов Spring в соответствии с условиями. \n" +
                "То есть - смотря какое условие будет выполнено, так и будет настроен наш бин перед созданием или после. (После, потому что я где-то читал что их выполнение можно также настраивать в рунтайме).\n" +
                "\n" +
                "Например: @Conditional, на основе каких-то определенных условий будет определять, следует ли создавать bean-компонент в контейнере или нет.\n" +
                "\n" +
                "Например я делал так:\n" +
                "@Component(\"name\")\n" +
                "// - Здесь тоже можно ставить эту аннотацию @Conditional(Gibbon.class)\n" +
                "public class Gibbon implements Condition {                           // Создаем какой то класс - компонент и имплементим его от функц. интерфейса Condition.\n" +
                "    @Override\n" +
                "    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { // И у него есть один единственный метод matches()\n" +
                "        System.out.println(\"matches worked!\");                                         // где мы и прописываем всю логику создания бина. (т.е. алгоритм).\n" +
                "        return true;                                                                   // Если метод вернет True, то бин создастся, а иначе нет.\n" +
                "    }\n" +
                "}\n" +
                "\n" +
                "@Bean(\"beanGibbon\")\n" +
                "@Conditional(Gibbon.class)                                           // Затем в конфиг. классе, в методе с @Bean, также указываем @Conditional(Gibbon.class)\n" +
                "public Gibbon beanGibbon(){\n" +
                "        return new Gibbon();\n" +
                "    }\n" +
                "Там можно создавать и более сложные условия, используя классы AnyNestedCondition, AllNestedConditions и NoneNestedConditions. // Но я не пробовал.\n" +
                "\n" +
                "То есть - аннотация @Conditional указывает, что БИН будет регистрироваться в контексте только тогда, когда все условия соответствуют.\n" +
                "\n" +
                "Условия проверяются непосредственно перед регистрацией компонента BeanDefinition, и они могут помешать регистрации данного BeanDefinition. \n" +
                "Поэтому нельзя взаимодействовать с бинами при проверке условий, потому что возможно их еще не существует.\n" +
                "\n" +
                "Также, мы можем проверить несколько условий, из нескольких классов. Для этого можно передать в @Conditional несколько классов с условиями:\n" +
                "@Conditional(Gibbon.class, Elephant.class)\n" +
                "\n" +
                "Если класс @Configuration пометить как @Conditional, то на все методы с аннотацией @Bean будут распространяться указанные условия.           +++++ ");
        spring.add("- Профили - позволяют нам разделять все бины на различные логические группы. Например: dev, test, prod. \n" +
                "\n" +
                "Например, нашему приложению нужны объекты транспортного средства. В морской среде мы будем создавать лодки, а в аэрокосмической среде создавать самолеты. \n" +
                "\n" +
                "Благодаря аннотации @Profile, можно активировать разные профили в разных средах. \n" +
                "Пример: @Profile(\"dev\"), @Profile(\"!dev\").\n" +
                "Таким образом можно загрузить только те бины, которые нам нужны.\n" +
                " В данном случае она чем-то похожа на @Conditional.\n" +
                "\n" +
                "Активировать профили можно в файле properties, можно в командной строке, можно в каком-нибудь веб-модуле. \n" +
                "Также активировать профили можно через: System.setProperty(\"spring.profiles.active\", \"prod\"); // Это я проверял. )\n" +
                "\n" +
                "Данную аннотацию можно применять на уровне класса или метода. Т.е. ее можно ставить над классами с аннотацией @Component или с аннотацией @Configuration.\n" +
                "Потом... аннотация @Profile может принимать в параметры имя одного или нескольких профилей. \n" +
                "\n" +
                "// И еще я где-то читал что она реализована с помощью вот этой аннотации @Conditional.\n" +
                "                   +++++");
        spring.add("- BeanFactory(фабрика бинов) — это интерфейс верхнего уровня (в Spring), он предоставляет механизмы конфигурации, которые управляют объектами любого типа. \n" +
                "// BeanFactory предоставляет всю инфраструктуру конфигурации и основные функциональные возможности. \n" +
                "// По сравнению с ApplicationContext - BeanFactory легче. \n" +
                "\n" +
                "ApplicationContext - это наследник BeanFactory и его подчиненный интерфейс. Он полностью реализует его функционал, добавляя свои специфические функции. \n" +
                "\n" +
                "Значит, в чем отличие:\n" +
                "1. Основное отличие в том, что в ApplicationContext все бины создаются сразу при запуске, а в BeanFactory - только по вызову метода. \n" +
                "// context.getBean(\"name\",Gibbon.class);\n" +
                "\n" +
                "2. ApplicationContext поддерживает все scop-ы бинов, а BeanFactory поддерживает только два - Singleton и Prototype.\n" +
                " \n" +
                "3. И еще в BeanFactory не работают транзакции и Spring AOP, а в ApplicationContext, получается - работают.\n" +
                "\n" +
                "4. Также ApplicationContext предоставляет еще несколько функций: \n" +
                "\ta. внедряет зависимости на основе аннотаций; \n" +
                "\tb. предоставляет доступ к MessageSource(источнику сообщений); \n" +
                "\tc. публикует ApplicationEvent(события) - для бинов, // реализующих интерфейс ApplicationListener (с помощью интерфейса ApplicationEventPublisher); \n" +
                "\td. позволяет интегрировать все функции Spring в Аспектно-ориентированном-программировании (AOP).\n" +
                " \n" +
                "5. ApplicationContext поддерживает автоматическую регистрацию BeanPostProcessor и BeanFactoryPostProcessor. А BeanFactory не поддерживает.\n" +
                "// И поэтому всегда желательно использовать ApplicationContext.\n" +
                " \n" +
                ">>> BeanPostProcessor — это интерфейс. Он позволяет настраивать бины прежде чем они попадут в контейнер.\n" +
                "                                                                                                                       +++++");
        spring.add("-- Жизненный цикл бина — это время существования объекта какого-либо класса. Состоит из следующих этапов:\n" +
                "-  Инициализация бина и внедрение всех зависимостей.\n" +
                "-  Если необходимо задать какое-либо действие при инициализации, то можно создать метод init() и пометить аннотацией @PostConstruct. \n" +
                "-  Создание бина.\n" +
                "-  Когда бин готов к использованию. Его можно получить с помощью метода getBean() из ApplicationContext.\n" +
                "-  После того как контекст будет закрыт, методом close(), бин уничтожается. Когда контейнер уничтожается, то всё содержимое тоже уничтожается. \n" +
                "-  Если необходимо задать какое-либо действие при уничтожении бина, то можно создать метод destroy(). И пометить его аннотацией @PreDestroy.\n" +
                "-(Во многие процессы жизненного цикла можно вмешаться, добавив туда собственную логику).\n" +
                "\n" +
                "Если подробно:\n" +
                "1. Сначала создаются описатели бина (BeanDefinition). \n" +
                "BeanDefinition — это такие объекты, которые содержат в себе всю информацию, так сказать описание будущего бина, по которому нужно будет создавать бин. \n" +
                "Для каждого бина создается свой объект BeanDefinition. Получается, сколько бинов в программе - столько и объектов BeanDefinition, которые их описывают. \n" +
                "BeanDefinition может содержать в себе следующие данные (метаданные): \n" +
                "   1. Имя класса с указанием пакета.\n" +
                "   2. Конфигурации бина, которая определяет, как бин должен вести себя в контейнере (scope, аргументы конструктора, ленивая загрузка или жадная, \n" +
                "   и другие там разные свойства.).     \n" +
                "   3. Ссылки на другие bean-компоненты, то есть какие у него имеются зависимости.  \n" +
                "   4. И другие параметры конфигурации, например такие как: ограничение количества соединений, используемых в бине, если он управляет пулом соединений. \n" +
                " \n" +
                "При конфигурации через аннотации используется класс AnnotationConfigApplicationContext. В параметрах нужно указать пакет сканирования или класс (или классы).\n" +
                "\n" +
                "Все классы сначала регистрируются в конфигурационном классе с аннотацией @Configuration, затем регистрируется специальный BeanFactoryPostProcessor, \n" +
                "который при помощи класса ConfigurationClassParser парсирует(собирает данные) из конфигурационного класса, загружает описания бинов (BeanDefinition).\n" +
                "\n" +
                "Затем создается хешмапа, в которой будут храниться все BeanDefinition-ы(описания) бинов, которые были обнаружены во время парсинга конфигурации. \n" +
                "// Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256); \n" +
                "\n" +
                "2. \n" +
                "Теперь, когда есть коллекция Map, в которой хранятся BeanDefinition-ы, все это дело нужно настроить.\n" +
                "Настройкой BeanDefinition-ов занимаются некие BeanFactoryPostProcessor-ы. \n" +
                "\n" +
                "В интерфейсе BeanFactoryPostProcessor всего один метод:\n" +
                " \n" +
                "public interface BeanFactoryPostProcessor {  \n" +
                "\tvoid postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; \n" +
                "} \n" +
                "\n" +
                "Вот в нем мы и прописываем всю настройку.\n" +
                "\n" +
                "// 3. Если конфигурация находится в XML-файле, то создаются кастомные фабрики бинов(FactoryBean).\n" +
                "\n" +
                "4. Затем, после этого, происходит создание самих экземпляров бинов. \n" +
                "Получается BeanFactory достает всю информацию, о том как создавать бины, из коллекции Map, т.е. достает оттуда все объекты BeanDefinition. \n" +
                "И на основе этих BeanDefinition-ов  BeanFactory - создает все экземпляры бинов.\n" +
                "\n" +
                "5. После того, как бины созданы, их тоже нужно настроить. \n" +
                "Настройкой занимается интерфейс BeanPostProcessor. Он настраивает бины еще до того как они попадут в контейнер. \n" +
                "Т.е. BeanPostProcessor - обрабатывают все... вот эти аннотации: @Autowired, @Inject, @Value и @Resource, и по ним он их и настраивает, как я понял. \n" +
                "Затем ApplicationContext, он же контейнер, начинает автоматический поиск готовых, настроенных бинов, и помечает их как “post-processors” и все эти бины теперь будут находиться в этом контейнере.\n" +
                "  \n" +
                "6. Все. Теперь когда бины готовы к использованию.\n" +
                "Их можно получить с помощью метода getBean() (из ApplicationContext). \n" +
                "\n" +
                "7. Потом, при закрытии контекста, с помощью метода close() все бины уничтожаются.\n" +
                "Если в бине есть метод, аннотированный @PreDestroy, то перед уничтожением вызовется этот метод, а в нем срабатывает вся прописанная в нем логика.  \n" +
                "*******************\n" +
                "Аннотация @PostConstruct - помечает метод, в котором мы можем прописать какую-то логику, сразу после инициализации свойств компонента (бина). \n" +
                "Такой метод вызывается только один раз, и может иметь любой уровень доступа, может иметь любой тип возвращаемого значения (хотя тип возвращаемого значения игнорируется Spring-ом и тогда лучше использовать void), метод не должен принимать аргументы. \n" +
                "Он также может быть статическим, только преимуществ такого использования метода нет, т.к. доступ у него будет только к статическим полям/методам бина. \n" +
                "Метод аннотированный @PostConstruct может использоваться, например, для заполнение базы данных. Срабатывает после конструктора (Я проверял).\n" +
                "\n" +
                "Аннотация @PreDestroy - помечает метод, когда нужно прописать какую-то логику непосредственно перед уничтожением бина. \n" +
                "Методы, аннотированные @PreDestroy, тоже (как и методы с @PostConstruct) могут иметь любой уровень доступа, но не могут быть статическими.  \n" +
                "Обычно такие методы используются для освобождения каких-то ресурсов или выполнение каких-то других задач, например по очистке таблицы из БД до того как \n" +
                "бин будет уничтожен. Или например, можно использовать для закрытия соединения с базой данных. \n" +
                " \n" +
                "Аннотации @PostConstruct и @PreDestroy не относятся к Spring-у и находятся в пакете javax.annotation. \n" +
                "Поэтому, для использования этих аннотаций, нужно добавить дополнительную зависимость: \n" +
                "<dependency>     \n" +
                "\t<groupId>javax.annotation</groupId>     \n" +
                "\t<artifactId>javax.annotation-api</artifactId>     \n" +
                "\t<version>1.3.2</version> \n" +
                "</dependency>                                                      +++++");
        spring.add("- Существует 2 области видимости по умолчанию.\n" +
                "* Singleton - это область видимости по умолчанию. Это означает, что в контейнере будет создан только один бин, и все запросы на него будут возвращать один и тот же бин. Например, сколько-бы раз мы не вызывали метод getBean(), он все равно будет возвращать один и тот же объект. \n" +
                "* Prototype - при вызове метода getBean(), при запросе, каждый раз возвращает новый объект. \n" +
                "У бинов с областью видимости “prototype” метод destroy() не вызывается (так как не берет на себя контроль полного жизненного цикла этого бина). \n" +
                "Spring не хранит такие бины в своём контексте (контейнере), а отдаёт их клиенту и больше о них не заботится (в отличие от синглтон-бинов).\n" +
                "\n" +
                "И еще есть 4 области видимости в веб-приложении. \n" +
                "Request - Область видимости для HTTP-запросов. (один HTTP запрос). Это означает что - на каждый запрос создается новый бин\n" +
                "* Session - Область видимости для сессий. (одна сессия). Т.е. на каждую сессию создается новый бин. \n" +
                "* Application - Область видимости — для жизненного цикла ServletContext. \n" +
                "* WebSocket - Область видимости — жизненного цикла WebSocket. \n" +
                "(Жизненный цикл web csope полный). \n" +
                "//Потом, \n" +
                "в пятой версии Spring-а не стало области видимости Global-session. А вместо нее появились Application и WebSocket.      +++++");
        spring.add("- Аннотация @ComponentScan сканирует пакеты, который мы указали и в нем она ищет в классы с аннотациями @Component, @Repository, @Service, @Controller и @Configuration. И... она прописывается вместе с @Configuration.\n" +
                "Если надо указать несколько пакетов для сканирования, то можно указать массив строк. \n" +
                "Также Spring будет искать бины во всех подпакетах указанного пакета.\n" +
                "\n" +
                "Также можно указать фильтры для поиска: includeFilters и excludeFilters.\n" +
                "Например: @ComponentScan.Filter(type=FilterType.CUSTOM)\n" +
                "\n" +
                "Или:      @ComponentScan(excludeFilters = @ComponentScan.Filter(type=FilterType.REGEX, pattern=\"com\\\\.baeldung\\\\.componentscan\\\\.springapp\\\\.flowers\\\\..*\"))\n" +
                "   \n" +
                "Для ComponentScan.Filter всего имеются пять фильтров:\n" +
                "ANNOTATION, \n" +
                "ASSIGNABLE_TYPE\n" +
                "ASPECTJ\n" +
                "REGEX\n" +
                "CUSTOM\n" +
                "\n" +
                "Эти фильтры нужны для того, что например, имея какой-то ненужный класс, создать для него фильтр, чтобы его бин не инициализировался.       +++++");
        spring.add("- Для работы с транзакциями Spring использует прокси Аспектно-ориентированного программирования.\n" +
                "- Для того чтобы управлять транзакциями первым делом надо разместить аннотацию @EnableTransactionManagement у класса-конфигурации @Configuration. \n" +
                "Если мы используем Spring Boot и имеем зависимости spring-data-* или spring-tx, то управление транзакциями будет включено по умолчанию. \n" +
                "\n" +
                "Потом мы можем использовать аннотацию @Transactional.\n" +
                "- Аннотация @Transactional - она определяет область действия одной транзакции.\n" +
                "- Если пометить аннотацией @Transactional какой-то класс или метод, то Spring создаст для него прокси. (Proxy - с англ. это заместитель или доверенное лицо).\n" +
                "И все методы будут обернуты в транзакционную логику. \n" +
                "\n" +
                "Когда мы вызываем такой метод: \n" +
                "- proxy соединяется с БД,\n" +
                " - открывает в нём транзакцию и сохраняет всё это в контексте.\n" +
                "- Затем, при необходимости всё это сохранённое достаётся и внедряется в бины.\n" +
                "\n" +
                "Если имеются несколько параллельных потоков, то будет и несколько параллельных транзакций, и они могут взаимодействовать между собой, согласно уровням изоляции. \n" +
                "\n" +
                "- Если один метод с @Transactional вызовет другой метод с @Transactional, то тогда второй транзакционный метод будет считаться частью первого. \n" +
                "И Spring не создаст для него proxy (для второго вызываемого метода), потому что ничего не будет знать о нем.\n" +
                "\n" +
                "- Если будет выброшено исключение, и это исключение указано в контракте метода -то отката транзакции не произойдет. (если в контракте описано этоисключение)\n" +
                "В транзакционном методе непроверенные(Unchecked) исключения можно ловить, а можно и не ловить. \n" +
                "\n" +
                "Также у аннотации @Transactional есть атрибут propagation: // Например: @Transactional(propagation = Propagation.MANDATORY)\n" +
                "REQUIRED — применяется по умолчанию. При входе в транзакционный метод, если никакой транзакции еще нет - то будет создана новая транзакция. А иначе будет использована уже существующая транзакция.\n" +
                "REQUIRES_NEW — при входе в метод, всегда создается новая транзакция, а ранее созданные транзакции приостанавливаются, пока не выйдем из метода.\n" +
                "NESTED — Если текущей транзакции не существует, будет создана новая. А при входе в метод в уже существующей транзакции создаётся savepoint, который по результатам выполнения метода будет либо сохранён, либо откачен.\n" +
                "MANDATORY — здесь всегда используется существующая транзакция и если текущей транзакции нет, то кидается исключение. \n" +
                "SUPPORTS — если транзакции нет - то метод так и выполнится без транзакции (как обычный метод), а иначе метод будет использовать текущую транзакцию. \n" +
                "NOT_SUPPORTED — при входе в метод, если есть текущая транзакция, то она будет приостановлена и метод продолжит выполняться без транзакции.\n" +
                "NEVER — запрещает исполнение транзакции явно (в наглую). А если при входе в метод будет существовать транзакция, будет выброшено исключение.\n" +
                "\n" +
                "Также кроме propagation есть еще другие атрибуты:\n" +
                " // Например: @Transactional(rollbackFor = Exception.class)\n" +
                "rollbackFor = Exception.class - если какой-либо метод выбросит указанное исключение, то тогда контейнер откатит текущую транзакцию. \n" +
                "rollbackForClassName и noRollbackForClassName - здесь имена исключений задаются в строковом виде.\n" +
                "readOnly - разрешает только операции чтения. \n" +
                "timeOut - Откатывает транзакции - которые не отвечают, через заданное время.\n" +
                "isolation - здесь указывается уровень изолированности транзакций. \n" +
                "(read committed, read uncommitted, repeatable read, serializable)\n" +
                "\n" +
                "// Распространение (Propagation) работает только если метод вызывает другой метод в другом сервисе. Если метод вызывает другой метод в этом же сервисе, то // используется this и вызов проходит мимо прокси (прокси - это заместитель). Это ограничение можно обойти при помощи самоинекции (self-injection).\n" +
                "\n" +
                "Аннотацию @Transactional - лучше всего использовать в слое Service.\n" +
                "\n" +
                "Для совершения транзакций обычно применяются такие-вот классы и интерфейсы:\n" +
                "1.\n" +
                "? TransactionInterceptor. У него есть только один метод invoke(...)(с англ. вызывать). Внутри него вызывается метод класса-родителя (TransactionAspectSupport) invokeWithinTransaction(...), а в его рамках происходят все транзакции.\n" +
                "? EntityManager - это интерфейс для создания и управления сущностями в JPA.\n" +
                "EntityManager - создается с помощью фабрики EntityManagerFactory. Пример: EntityManager entityManager = entityManagerFactory.createEntityManager();\n" +
                "  \n" +
                "? TransactionManager - он решает, создавать ли новую транзакцию или нет. Или - создавать ли новый EntityManager или нет.\n" +
                "\n" +
                "2. Transaction  Interceptor. (Перехватчик транзакции). \n" +
                "\n" +
                "В TransactionInterceptor код отрабатывается до момента вызова метода save(), и в нем уже будет определяется: выполнить ли метод save() в пределах уже существующей транзакции БД или стартовать новую транзакцию. \n" +
                "Далее решение будет делегироваться TransactionManager-у.\n" +
                " \n" +
                "Это в том случае, если наш метод был обёрнут в блоке try-catch:\n" +
                "\n" +
                "     \n" +
                "try {\n" +
                "        \n" +
                "\ttransaction.begin();         // логика до\n" +
                "        \n" +
                "\tservice.save();         \n" +
                "        \n" +
                "\ttransaction.commit();      // логика после\n" +
                "      \n" +
                "} catch(Exception ex) {\n" +
                "       \n" +
                "\ttransaction.rollback();\n" +
                "       \n" +
                "\tthrow ex;\n" +
                "      \n" +
                "}\n" +
                "\n" +
                "3. TransactionManager. \n" +
                "Менеджер транзакций должен предоставить ответ на два вопроса:\n" +
                "? Должен ли создаться новый EntityManager?\n" +
                "? Должна ли стартовать новая транзакция БД? \n" +
                "\n" +
                "Решение принимается, основываясь на следующих фактах: \n" +
                "? выполняется ли хоть одна транзакция в текущий момент или нет; \n" +
                "? а также на основании атрибута «propagation» в @Transactional.\n" +
                " \n" +
                "Если TransactionManager решил создать новую транзакцию, тогда:\n" +
                "? Создается новый EntityManager; \n" +
                "? EntityManager «привязывается» к текущему потоку (Thread); \n" +
                "\n" +
                "4. EntityManager proxy. \n" +
                "Когда метод save() слоя Service делает вызов метода save() слоя DAO, внутри которого вызывается, например, entityManager.persist(), то не происходит вызов метода persist() напрямую у EntityManager. \n" +
                "Вместо этого метод вызывает EntityManager proxy, который достает текущий EntityManager для нашего потока, и у него вызывается метод persist(). \n" +
                "\n" +
                "5. Отрабатывает DAO-метод save().\n" +
                "\n" +
                "6. TransactionInterceptor. \n" +
                "\n" +
                "Отработает код после работы метода save(), а именно будет принято решение по коммиту/откату транзакции. \n" +
                "\n" +
                "Кроме того, если мы в рамках одного метода сервиса обращаемся не только к методу save(), а к разным методам Service и DAO, то все они буду работать в рамках одной транзакции, которая оборачивает этот метод сервиса.\n" +
                "\n" +
                "Если вызвать метод с @Transactional, из которого вызвать метод без @Transactional, то оба будут отработаны в рамках прокси и будут обернуты в нашу транзакционную логику. \n" +
                "\n" +
                "А если мы вызовем метод без @Transactional, из которого вызовем метод с @Transactional, то они уже не будут работать в рамках прокси и не будут обернуты в нашу транзакционную логику.               +-+-+-+-+-+-+-+-+-+ (Еще надо почитать).");
        spring.add(">>> Контроллер - это обработчик веб-запросов.\n" +
                "- @Controller - это аннотация указывает что класс является контроллером, который обрабатывает HTTP-запросы(и часто используется с аннотацией @RequestMapping)\n" +
                "Методы контроллера обычно возвращают представление html-странички // или другие объекты.\n" +
                "@GetMapping(\"/{id}\") \n" +
                " public Human getId(@PathVariable int id) { \n" +
                " return human.findById(id); \n" +
                " } \n" +
                "- \n" +
                "@RestController ставится на класс-контроллер вместо @Controller. Она указывает, что этот класс обслуживает REST API и оперирует (не моделями, а) данными. \n" +
                "@RestController включает в себя вот эти две аннотации: @Controller и @ResponseBody. Т.е. это не что иное, как сочетание аннотации @Controller и @ResponseBody \n" +
                "\n" +
                "//  Cледующие два фрагмента кода в Spring MVC равны:\n" +
                "\n" +
                "@Controller\n" +
                "@ResponseBody\n" +
                "public class MVCController {\n" +
                "   .. your logic\n" +
                "}\n" +
                "@RestController\n" +
                "public class RestFulController {\n" +
                "  .... your logic\n" +
                "}\n" +
                "\n" +
                "Метод Rest-контроллера обычно возвращает какие-то данные. На предпроджекте они у меня возвращали: return new ResponseEntity<>(\"Hello World!\", HttpStatus.OK).\n" +
                "@GetMapping(\"/hello\")\n" +
                "ResponseEntity<String> hello() {\n" +
                "    return new ResponseEntity<>(\"Hello World!\", HttpStatus.OK);\n" +
                "}\n" +
                "Аннотация @ResponseBody сообщает контроллеру, что возвращаемый объект автоматически сериализуется в JSON или XML (используя Jackson-converter) и передается обратно в объект HttpResponse. \n" +
                "\n" +
                "Чтобы вернуть ответ со своим статусом, можно просто вернуть объект ResponseEntity. Например пишем: return ResponseEntity.status(213); \n" +
                "\n" +
                "// ResponseEntity он используется для формирования HTTP-ответа. И у него есть параметры (заголовки, код статуса и тело ответа). \n" +
                "\n" +
                "// Во всех остальных случаях достаточно использовать @ResponseBody.\n" +
                "// Если мы хотим использовать ResponseEntity, то просто должны вернуть его из метода-контролера, Spring позаботится обо всем остальном.\n" +
                " \n" +
                "                                                                                                                                            +++++");
        spring.add("- ViewResolver - это такой интерфейс, и это распознаватель представлений, он работает с представлениями(т.е. html-файлами), и поддерживает их распознавание на основе имени, которое возвращает контроллер. \n" +
                "\n" +
                "У Spring-а имеется много классов реализующих ViewResolver. \n" +
                "Например: \n" +
                "- InternalResourceViewResolver — это реализация ViewResolver по умолчанию. Она находит представления, которые возвращают контроллеры. \n" +
                "А потом сразу переходит к этим представлениям. Поиск ведется по заданному пути, префиксу, суффиксу и имени.\n" +
                "\n" +
                "- UrlBasedViewResolver - он преобразует логические имена в URL.\n" +
                " Ну тоже, похоже находит какие-то строки, только потом переводит их в URL-адреса.\n" +
                " \n" +
                "Существует также еще несколько реализаций (чтобы интегрироваться с различными технологиями представлений). Например: \n" +
                "FreeMarker (FreeMarkerViewResolver), Velocity (VelocityViewResolver) и JasperReports (JasperReportsViewResolver).             +++++");
        spring.add("- Model - интерфейс, который представляет коллекцию пар ключ-значение Map<String, Object>. Обычно используется в методах-контроллера. Хранит в себе модели.\n" +
                "// Содержимое модели используется для отображения данных во View. \n" +
                "\n" +
                "Например, если View будет выводить информацию об объекте Human, то она может ссылаться к ключам модели, например humanName, humanPhone, и получать \n" +
                "значения для этих ключей. \n" +
                "Объекты-значения из модели также могут содержать бизнес-логику. \n" +
                "- \n" +
                "ModelMap - это класс, который наследуется от LinkedHashMap. Он тоже, как и Model, используется для передачи значений во Вью для визуализации представления. \n" +
                "Но он передает и обрабатывает коллекцию значений, так - как будто они были были внутри Map-ы. \n" +
                "Имеет все преимущества LinkedHashMap, плюс еще несколько своих собственных методов.\n" +
                "- \n" +
                "ModelAndView - является контейнером для ModelMap. Он может одновременно хранить в себе и модели и представления. \n" +
                "Это позволяет контроллеру возвращать все значения как одно.\n" +
                " \n" +
                "- Получается - объект Model-и мы передаем в метод контроллера, а он уже оттуда вытаскивает все необходимые данные и посредством Thymeleaf - эти данные преобразует в наше представление html. Это я так понимаю.\n" +
                "\n" +
                "// View используется для отображения данных приложения пользователю.\n" +
                " У View есть несколько поставщиков View (и они называются шаблонизаторы) \n" +
                "// Например: — JSP, JSF, Thymeleaf, и т.п.\n" +
                "                                             +++++");
        spring.add("- MVC — это такой шаблон проектирования. В нем программа делится на 3 вида компонентов: \n" +
                "Model — модель отвечает за хранение данных. \n" +
                "View — отвечает за вывод данных на фронтенде. \n" +
                "Controller — он как бы стоит посерединке. Он оперирует моделями и производит обмен данными между model и view.  \n" +
                "\n" +
                "Принципы MVC были созданы, чтобы — отделить всю реализацию бизнес-логики приложения (модели) от ее визуализации (view). Вот как раз - фреймворк Spring MVC этим и занимается.\n" +
                " \n" +
                "Spring MVC - это веб-фреймворк, основанный на Servlet API.  // Он использует два шаблона проектирования - Front controller и MVC.\n" +
                " \n" +
                "Spring MVC включает в себя набор важных компонентов, таких как: \n" +
                "Dispatcher Servlet, Controllers, View Resolvers, Views, Models, ModelAndView, Model and Session Attributes, которые полностью независимы друг от друга. \n" +
                "\n" +
                "Основные интерфейсы, которые использует Spring MVC, для обработки запросов:\n" +
                "- DispatcherServlet - это самый главный контроллер. Он получает запросы и распределяет их между другими контроллерами. \n" +
                "- HandlerMapping - выбирает классы и его методы, которые должны обработать данный входящий запросы.\n" +
                "- Controller — оперирует моделями и отвечает за обмен данными model с view.\n" +
                "- ViewResolver. Определяет - какое именно View(представление) должно быть показано клиенту на основе имени, полученного от контроллера.\n" +
                "- View. Отвечает за отображение в виде текстов и изображений. (Некоторые запросы могут идти прямо во View, не заходя в Model). \n" +
                "- HandlerAdapter. Помогает DispatcherServlet вызвать и выполнить метод-контроллер для обработки входящего запроса.\n" +
                "- ContextLoaderListener - это слушатель класса WebApplicationContext в Spring-e (Cлушает при старте и завершении). \n" +
                "Также он связывает все жизненные циклы ApplicationContext и ServletContext, и автоматически создает ApplicationContext. \n" +
                "\n" +
                "Последовательность событий, соответствующая входящему HTTP-запросу:\n" +
                "\n" +
                "? После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой Контроллер (Controller) должен быть вызван, после чего HandlerAdapter, отправляет запрос в нужный метод Контроллера.\n" +
                "? Контроллер принимает запрос и вызывает соответствующий метод. Вызванный метод формирует данные Model и возвращает их в DispatcherServlet вместе с именем View (как правило - это имя html-файла). \n" +
                "? При помощи интерфейса ViewResolver DispatcherServlet определяет, какое View нужно использовать на основании имени, полученного от контроллера.\n" +
                "? если это REST-запрос на сырые данные (JSON/XML), то\n" +
                "DispatcherServlet сам его отправляет, минуя ViewResolver;\n" +
                "  ? если обычный запрос, то DispatcherServlet отправляет данные Model в виде атрибутов во View - шаблонизаторы Thymeleaf, FreeMarker и т.д., которые сами отправляют ответ.\n" +
                " \n" +
                "Как я понял DispatcherServlet здесь - это ключевое звено!                                       +++++");
        spring.add("- Front controller - это такой паттерн, это означает что есть какая-то единая точка входа для всех входящих запросов. \n" +
                "И все http-запросы сначала обрабатываются одним главным обработчиком – DispatcherServlet (с маппингом “/”), а затем распределяет их между контроллерами.\n" +
                "Он получается, выполняет сам: аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем делегирует все эти запросы другим контроллерами, которые обрабатывают разные URL. Это и есть реализация паттерна Front Controller.\n" +
                " \n" +
                "В каждом Веб-приложении может может находиться любое количество DispatcherServlet-ов. И каждый из них будет работать на своей собственной террритории(в своем собственном пространстве имен), и у каждого DispatcherServlet-а будет свой собственный WebApplicationContext с вьюшками, контроллерами и т.д.\n" +
                "\n" +
                "Потому что Spring позволяет иметь несколько контекстов одновременно. \n" +
                "? Одним из них будет корневой контекст, а все остальные контексты будут дочерними. \n" +
                "? Все дочерние контексты могут получить доступ к бинам, определенным в корневом контексте, но не наоборот. \n" +
                "? Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста.      +++++");
        spring.add("- Аспектно-ориентированное программирование (АОП) — это такая парадигма программирования, которая повышает модульность приложения за счет разделения междисциплинарных задач. \n" +
                "Это когда мы можем добавить дополнительное поведение к существующему коду без изменения самого кода.  \n" +
                "\n" +
                "С помощью АОП, мы можем реализовать так сказать - сквозную логику, которая применяется к множеству частей приложения - и вся эта логика может автоматически  применена ко всему приложению.  \n" +
                "\n" +
                "И у Spring-а есть особый подход к АОП: т.е. он, например может (динамически) создавать прокси для всех необходимых объектов и привязывать эти объекты к к определенной конфигурирации. И затем уже будет выполняться сквозная логика. \n" +
                "// Прокси - это как оболочка для какого-то объекта, или защита. Ее еще называют заместителем объекта, потому что она принимает все удары на себя.\n" +
                "\n" +
                "Например, у нас есть какая-то функциональность, и мы хотим ее внедрить в наше приложение, не изменяя ничего в нашем коде. И эта функциональность должна работать в определенных участках нашего кода, а таких участков (или модулей) может быть очень много. Получается что наша функциональность стоит где-то в сторонке, и когда мы применяем АОП, она как-бы обволакивает все выделенные участки основного кода и к каждому модулю наша функциональность применяется по отдельности. Например: мы можем залогировать отдельные участки нашего кода применяя сквозную логику АОП, и благодаря этому нам не придется прописывать в каждом участке кода LOGGER = Logger.getLogger(Main.class.getName()); LOGGER.log(Level.INFO,\"Начало нашей программы!\");\n" +
                "// Или есть такой пример с зефиром, вафлей и шоколадом.\n" +
                "\n" +
                "Потом в АОП, есть такие понятия:\n" +
                "Join point — это такие контрольные точки присоединения, которые находятся внутри основного кода, где планируется введение функциональности.\n" +
                "Pointcut — это запрос точек присоединения, т.е. можно выбрать несколько этих Join point-ов (его еще называют срез) - и повесить на них Advice.\n" +
                "Advice — набор инструкций выполняемых на точках среза (Pointcut), т.е. та самая сквозная логика.        Инструкции выполняются по событию разных типов:\n" +
                "\n" +
                "* Before — перед вызовом метода\n" +
                "* After — после вызова метода\n" +
                "* After returning — после возврата значения из метода.\n" +
                "* After throwing — в случае exception \n" +
                "* After finally — в случае выполнения блока finally \n" +
                "* Around(вокруг) — можно вставить как - перед методом, так и после метода, а также вообще обойти вызов метода.\n" +
                "\n" +
                "И кстати, на один Pointcut можно «повесить» несколько Advice-инструкций с разными типами. \n" +
                "\n" +
                "// Вообще Aspect — это модуль в котором собраны описания Pointcut и Advice.\n" +
                "\n" +
                "Ну про аннотации я наверное ничего не смогу рассказать. Там, для всех этих операций - естественно есть аннотации, такие как: \n" +
                "- @Aspect, @Pointcut, @Before, @After, и.т.д. Ну тут названия говорят сами за себя. Я уже особо глубоко не вникал...                     +++++");
        spring.add("- Filter(фильтр) - это интерфейс (из пакета javax.servlet). Он фильтрует данные запросов и ответов - либо когда запрос идет к ресурсу, либо фильтрует ответ от ресурса, либо фильтрует в обоих направлениях. \n" +
                "\n" +
                "Обычно фильтрация выполняется в методе doFilter(). У каждого фильтра есть доступ к объекту FilterConfig, в котором происходит его инициализация.\n" +
                "И еще есть ссылка на ServletContext, \n" +
                "который он может использовать, например, для загрузки ресурсов, необходимых для фильтрации.\n" +
                "// А вообще фильтры настраиваются в дескрипторе развертывания веб-приложения.\n" +
                "\n" +
                "Также можно создавать цепочки из этих фильтров. В таком случае веб-сервер решает сам, какой фильтр вызывать первым, \n" +
                "т.е.\n" +
                " в каком порядке они у него зарегистрированы, в таком порядке они и будут вызываться. \n" +
                "Когда в программе вызывается метод doFilter(...) первого фильтра, то веб-сервер создает объект FilterChain, внутри которого идет цепочка фильтров, и передаёт её в метод doFilter(). \n" +
                "\n" +
                "- Interceptor(перехватчик) - это интерфейс (из пакета org.aopalliance.intercept), предназначенный для аспектно-ориентированного программирования.\n" +
                " \n" +
                "Когда у нас в Spring-е, запрос из ДиспетчерСервлета отправляется в Controller, перед тем как он в него попадёт, его могут перехватить вот эти вот  перехватчики Interceptor (0 или более). \n" +
                "Interceptor-ы можно использовать, например для выполнения таких задач, как запись в Log, добавление или обновление конфигурации перед тем, как запрос обработается Controller-ом. \n" +
                "\n" +
                "Здесь тоже, (как и в случае с фильтрами) можно создавать цепочки перехватчиков.\n" +
                "Есть такой - стек перехватчиков: и он как раз занимается связыванием перехватчиков в цепочку в каком-то определенном порядке. \n" +
                "В этой цепочке перехватчиков, они тоже вызываются в том же порядке, в котором были определены изначально. \n" +
                "\n" +
                "Interceptor-ы обычно используются для выполнения какой-то логики перед тем как данные попадут в контроллер, после обработки данных в контроллере их тоже можно перехватить, и даже когда уже Представление(Вью) сформировано - интерцепторы тоже могут использоваться. \n" +
                "Также с помощью Interceptor-ов мы можем вообще запретить выполнение метода контроллера. // Мы можем указать любое количество перехватчиков. \n" +
                "\n" +
                "- Listener(слушатель) - это класс, он реализует интерфейс javax.servlet.ServletContextListener. \n" +
                "Он инициализируется только один раз при запуске веб-приложения и уничтожается при остановке веб-приложения. \n" +
                "Чтобы создать свой Listener - надо создать класс, и имплементировать интерфейс ServletContextListener и поставить над ним аннотацию @WebListener.\n" +
                "\n" +
                "Слушатель сидит и ждет, когда произойдет указанное событие, затем «перехватывает» событие и запускает собственное событие (видимо запускает для других сллей)\n" +
                "\n" +
                "Мы можем использовать ServletContextListener - который будет запускать наш код до запуска веб-приложения. \n" +
                "\n" +
                "// В нашем веб-приложении - все ServletContextListener-ы уведомляются об инициализации и уничтожении контекста (еще до того как все фильтры и сервлеты будут \n" +
                "// проинициализированы или уничтожены). \n" +
                "\n" +
                ">>> Обратный вызов функции - это когда мы в параметры одной функции передаем другую функцию, и эта другая функция тоже начинает выполняться.\n" +
                "\n" +
                "Разница - Filter vs. Interceptor. \n" +
                "? Перехватчик основан на механизме Рефлексии, а фильтр основан на обратном вызове функции. \n" +
                "? Фильтр зависит от контейнера сервлета, а перехватчик не зависит от него. \n" +
                "? Перехватчики работают только с запросами к контроллерам, а фильтры работают почти со всеми запросами (например, js, .css и т.д.). \n" +
                "? Перехватчики - могут обращаться к объектам в контейнере Spring, - а фильтры не могут.                    +++++");
        spring.add("- Да, можно. Для этого в методе контроллера в параметрах можно указать массив или коллекцию:\n" +
                "\n" +
                "http://localhost:8080/login?name=Ranga&name=Ravi&name=Sathish \n" +
                "\n" +
                "public String method(@RequestParam(value=\"\"name\"\") String[] names){...} \n" +
                "\n" +
                "http://localhost:8080/api/foos?id=1,2,3\n" +
                " \n" +
                "public String getFoos(@RequestParam List<String> id){...}");
        spring.add("- Spring Security обеспечивает - защиту и безопасность. Он представляет из себя - цепочку фильтров, которые интегрированы в контейнер сервлетов.\n" +
                "Этот список фильтров находится в классе FilterChainProxy.\n" +
                "Он может обеспечивать аутентификацию, авторизацию и защиту от распространенных эксплойтов. \n" +
                "\n" +
                ">>> Экспло?йт — компьютерная программа, фрагмент программного кода или последовательность команд, использующие уязвимости в программном обеспечении и применяемые для проведения атаки на вычислительную систему.\n" +
                "\n" +
                "Каждый фильтр Spring Security реализует какой-то отдельный механизм безопасности. \n" +
                "\n" +
                "И этот механизм безопасности состоит из следующих блоков, т.е. классов и интерфейсов безопасности: \n" +
                "Сначала идет SecurityContextHolder - это место, где Spring Security хранит информацию о том, кто аутентифицирован. Он также обеспечивает доступ к SecurityContext-у.\n" +
                " В механизме Spring Security - он является самым главным и фундаментальным.\n" +
                "\n" +
                "SecurityContext - интерфейс, который обеспечивает безопасность для текущего потока. Является контейнером для объекта типа Authentication. \n" +
                "(Аналог - ApplicationContext, в котором лежат бины).\n" +
                "\n" +
                "Authentication - это объект, который содержит информацию о текущем пользователе и его привилегиях. Т.е. у каждого пользователя свой объект Authentication.\n" +
                "\n" +
                "GrantedAuthority - содержит информацию о полномочиях пользователей, например, роли или уровни доступа. \n" +
                "\n" +
                "UserDetails - это интерфейс, который представляет учетную запись пользователя. Класс (модель) нашего пользователя должен его имплементировать. \n" +
                "Учетная запись пользователя, которая хранится в данном интерфейсе хранит в себе такую информацию как логин, парол, роль и.т.д.\n" +
                "И как раз каждый объект Authentication формируется на основании этой учетной записи, т.е. на основании UserDetalis.\n" +
                "\n" +
                "UserDetailsService - (интерфейс) он реализует загрузку данных о пользователе из хранилища. Созданный объект от этого интерфейса обращается к БД и вытаскивает оттуда юзеров. Единственный метод этого интерфейса (loadUserByUsername(String username)) принимает имя пользователя в виде String и возвращает UserDetails. \n" +
                "\n" +
                "AuthenticationManager - это основной интерфейс для аутентификации. Имеет только один метод authenticate(Authentication authentication), который срабатывает, когда пользователь пытается аутентифицироваться в системе.\n" +
                "\n" +
                "PasswordEncoder - интерфейс для шифрования/расшифровывания паролей. Это одна из реализаций - BCryptPasswordEncoder.\n" +
                "\n" +
                "Credentials(реквизиты для входа) - объект этого класса подтверждает учетную запись пользователя, но им может быть и отпечаток пальца, фото сетчатки и т.п.\n" +
                "\n" +
                "Короче, самое главное что я запомнил (из рисунка):\n" +
                "Сначала идет SecurityContextHolder, внутри него (как в матрешке) лежит SecurityContext. \n" +
                "Внутри SecurityContext лежит Authentication. А внутри Authentication уже лежат: Principal, Credentials и Authorities.\n" +
                "\n" +
                "Principal - интерфейс, который содержит в себе учетную запись пользователя. Authorities - хранит в себе права пользователя.\n" +
                "\n" +
                "// MODE_GLOBAL - все потоки Java-машины используют один контекст безопасности. \n" +
                "\n" +
                "// MODE_INHERITABLETHREADLOCAL - потоки порожденные от одного защищенного потока.\n" +
                "\n" +
                "Пример кода:\n" +
                "@Entity\n" +
                "public class User implements UserDetails {  // Создаем Юзера и имплементим его от UserDetails.\n" +
                "\n" +
                "    @Override\n" +
                "    public Collection<? extends GrantedAuthority> getAuthorities() { // От UserDetails в этом классе переходят вот эти методы, и еще там есть методы...\n" +
                "        return roles;\n" +
                "    }\n" +
                "\n" +
                "    @Override\n" +
                "    public String getUsername() {\n" +
                "        return name;\n" +
                "    }\n" +
                "\n" +
                "}  \n" +
                "\n" +
                "@Configuration\n" +
                "@EnableWebSecurity\n" +
                "public class SecurityConfig extends WebSecurityConfigurerAdapter {  // Создаем класс конфигурации и экстендим его от WebSecurityConfigurerAdapter.\n" +
                "\n" +
                "   @Override\n" +
                "    protected void configure(HttpSecurity http) throws Exception {  // Переопределяем метод configure(HttpSecurity http).\n" +
                "        http\n" +
                "                .authorizeRequests()\n" +
                "                .antMatchers(\"/login\").anonymous()\n" +
                "                .antMatchers(\"/\",\"/delete/**\").hasAuthority(\"ADMIN\")\n" +
                "                .antMatchers(\"/user\").hasAuthority(\"USER\")\n" +
                "                .and()\n" +
                "                .formLogin()\n" +
                "                .loginPage(\"/login\")\n" +
                "                .loginProcessingUrl(\"/login\")\n" +
                "                .usernameParameter(\"j_email\")\n" +
                "                .passwordParameter(\"j_password\")\n" +
                "                .permitAll()\n" +
                "                .successHandler(loginSuccessHandler);\n" +
                "\n" +
                "        http.logout()\n" +
                "                .permitAll()\n" +
                "                .logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\"))\n" +
                "                .logoutSuccessUrl(\"/login\")\n" +
                "                .and().csrf().disable();\n" +
                "    }\n" +
                "}\n" +
                "\n" +
                "Процесс аутентификации: \n" +
                "\n" +
                "1. UsernamePasswordAuthenticationFilter получают имя пользователя и пароль и создает экземпляр класса UsernamePasswordAuthenticationToken (экземпляр интерфейса Authentication).\n" +
                " // UsernamePasswordAuthenticationFilter и UsernamePasswordAuthenticationToken - классы, они реализуют интерфейс Authentication.\n" +
                "2. Токен передается экземпляру AuthenticationManager для проверки.\n" +
                " \n" +
                "3. AuthenticationManager в случае успешной аутентификации, возвращает полностью заполненный экземпляр Authentication. \n" +
                "\n" +
                "4. И затем уже, через метод SecurityContextHolder.getContext().setAuthentication(...), в SecurityContext-е сохраняется возвращенный экземпляр Authentication.\n" +
                "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+++++ ");
        spring.add("- Spring Boot - это платформа (один из модулей Spring) для быстрой разработки автономного и производительного приложения, которое можно запустить с минимальными настройками.\n" +
                "Имеет набор уже настроенных модулей, которые упрощают конфигурацию приложения, написанного на Spring.\n" +
                "Здесь все настраивается автоматически, ручные настройки не требуются. \n" +
                "Выбирая одну версию Spring Boot, мы неявно выбираем десятки зависимостей, которые без фреймворка пришлось бы настраивать вручную. \n" +
                "Точка входа в приложение — это класс, содержащий аннотацию @SpringBootApplication и метод main().\n" +
                "Spring Boot автоматически сканирует все компоненты, включенные в проект, используя аннотацию @ComponentScan .\n" +
                "Имеет встроенные утилиты, которые автоматизируют процедуру настройки и ускоряют процесс создания и развертывания Spring-приложений.\n" +
                "\n" +
                "Самые важные особенности Spring Boot это - управление зависимостями, автоматическая конфигурация и встроенные контейнеры сервлетов.\n" +
                "\n" +
                "Поэтому, при использовании Spring Boot, файл pom.xml содержит намного меньше строк, чем при использовании его в обычных Spring-приложениях.\n" +
                "После выбора подходящего starter-пакета, Spring Boot автоматически настраивает Spring-приложение на основе добавленных jar-зависимостей.\n" +
                "Например, если добавить Spring-boot-starter-web, Boot автоматически сконфигурирует все необходимые бины для работы с веб.\n" +
                "Если использовать spring-boot-starter-jdbc, Boot автоматически зарегистрирует бины для работы с б.д.\n" +
                "Если нам не нужно использовать базу данных, то можно не предоставлять никаких сведений о подключении к БД, и тогда Boot автоматически настроит базу в памяти, без какой-либо конфигурации.\n" +
                "Автоматическую конфигурацию можно переопределить в любой момент, это делается с помощью пользовательских настроек.\n" +
                "Потом - каждое Spring Boot-приложение включает в себя встроенный web-сервер Tomcat.\n" +
                "\n" +
                "Для настройки и запуска Spring Boot приложений требуется:\n" +
                "Java 8 и выше (с более ранними версиями Spring Boot не работает).\n" +
                "Maven 3 и выше.\n" +
                "Добавить Spring Boot плагин.\n" +
                "Добавить <packaging>jar</packaging> , чтобы Maven генерировал исполняемый jar-файл при сборке проекта.\n" +
                "Также, на сайте: start.spring.io можно собрать проект, просто указав необходимые стартеры.\n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n" +
                "// Spring Boot сам знает какую версию зависимостей нужно подгружать. \n" +
                "- При использовании аннотации @EnableAutoConfiguration, работающей совместно с @ComponentScan - Spring Boot настроит приложение на основе зависимостей, которые были добавлены в в pom.xml-файл. \n" +
                "При использовании аннотации @SpringBootApplication, можно не добавлять аннотации: @EnableAutoConfiguration, @ComponentScan и @SpringBootConfiguration. Аннотация @SpringBootApplication включает в себя все эти аннотации.\n" +
                "\n" +
                "Чтобы ускорить процесс управления зависимостями, Spring Boot неявно упаковывает необходимые зависимости, и предоставляет их разработчику через starter-пакеты (spring-boot-starter-web, spring-boot-starter-data-jpa и т.д.)\n" +
                "Starter-пакеты - это набор зависимостей, которые можно включить в свое приложение. \n" +
                "\n" +
                "Например, если нужно начать использовать Spring Data JPA, для доступа к БД, можно включить зависимость spring-boot-starter-data-jpa и все будет работать (и даже не придется искать совместимые драйверы баз данных и библиотеки Hibernate).\n" +
                "Если нужно создать Spring web-приложение, можно добавить зависимость spring-boot-starter-web, которая подтянет в проект все библиотеки, необходимые для разработки Spring MVC-приложений.\n" +
                "Короче, Spring Boot собирает все общие зависимости и определяет их в одном месте, что позволяет разработчикам просто их использовать, без всяких заморочек.\n" +
                "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n" +
                "\n" +
                "// Чтобы включить автоматическуя конфигурацию, используется аннотацией @EnableAutoConfiguration. \n" +
                "\n" +
                "// Если наш код уже зарегистрировал бин DataSource — автоконфигурация его переопределять не будет.\n" +
                "\n" +
                "// Также Boot имеет готовые к работе функции, такие как метрики, security и внешняя конфигурация.\n" +
                "\n" +
                "Также Boot имеет инструмент CLI (command-line interface) для разработки и тестирования приложения Spring Boot.\n" +
                "\n" +
                "Также Boot поддерживает конфигурации и XML и аннотаций.\n" +
                "\n" +
                "Автоматическая конфигурация в Spring Boot происходит следующим образом:\n" +
                "1. Сначала нужно отметить Main класс аннотацией @SpringBootApplication \n" +
                "(эта аннотация инкапсулирует в себе: @SpringBootConfiguration, @ComponentScan, @EnableAutoConfiguration), \n" +
                "И эта аннотация (\n" +
                "@SpringBootApplication) запускает сканирование компонентов, запускает автоконфигурацию и показывает разным компонентам Spring, что это Spring Boot приложение.\n" +
                "\n" +
                "2. Затем нужно указать @EnableAutoConfiguration (импортирует класс EnableAutoConfigurationImportSelector). Т.е. включить автоматическую конфигурацию. \n" +
                "\n" +
                "3. Когда мы указываем @EnableAutoConfiguration - класс EnableAutoConfigurationImportSelector импортирует ВСЕ необходимые бины в контекст приложения. \n" +
                "Их там более 150, и находятся они в META-INF/spring.factories конфигурации.\n" +
                "\n" +
                "4. // Каждая из этих конфигураций пытается сконфигурировать различные аспекты приложения (web, JPA, AMQP и т.д.), регистрируя нужные бины. \n" +
                "\n" +
                "5. Затем созданный AnnotationConfigEmbeddedWebApplicationContext ищет в контейнере фабрику для запуска embedded servlet container.\n" +
                "\n" +
                "6. Все. Потом Servlet container запускается, приложение готово к работе.                                   +++++");
        spring.add("- \n" +
                "? Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods).\n" +
                "? Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6)\n" +
                "? Поддержка HTTP/2 (TLS, Push), NIO/NIO.2.\n" +
                "? Поддержка Kotlin\n" +
                "? Реактивность (веб-инфраструктура с реактивным стеком, «Spring WebFlux»)\n" +
                "? Null-safety аннотации(@Nullable), новая документация.\n" +
                "? Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0). \n" +
                "? Поддержка JUnit 5 + Testing Improvements (conditional and concurrent)\n" +
                "? Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava\".                              +++++");
        spring.add("");
    }
}
