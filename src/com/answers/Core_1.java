package com.answers;

import java.util.ArrayList;
import java.util.List;

public class Core_1 {

    public static List<String> core_1 = new ArrayList<>();

    static {
        core_1.add("- ООП - методология программирования, где программа может быть представлена в виде совокупности объектов, каждый из которых является экземпляром определенного класса, и эти классы образуют иерархию наследования.\n" +
                "Согласно парадигме ООП программа состоит из обьектов, которые могут обмениваться сообщениями. Обьекты могут обладать состоянием, и единственный способ изменить состояние обьекта - передать ему сообщение. И в ответ на это сообщение обьект может изменить свое собственное состояние. \n" +
                "Класс — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора. \n" +
                "Объект – это экземпляр класса, созданный на основе этого описания(т.е. класса).");
        core_1.add("- Легко читается - не нужно выискивать в коде функции и выяснять, за что они отвечают.\n" +
                "- Быстро пишется - можно быстро создать сущности, с которыми должна работать программа.\n" +
                "- Простота реализации большого функционала - т.к. на написание кода уходит меньше времени, можно быстро создать приложение с множеством возможностей.\n" +
                "- Меньше повторений кода - не нужно писать однотипные функции для разных сущностей.");
        core_1.add("- Снижает производительность - потому что многие вещи технически реализованы иначе, поэтому они используют больше ресурсов.\n" +
                "- Сложно начать - парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени.");
        core_1.add("- Инкапсуляция, \n" +
                "Наследование, \n" +
                "Полиморфизм. (И также дополнительно - Абстракция).");
        core_1.add("- \n" +
                "Свойство системы, которое объединяет(инкапсулирует) данные и методы. И эти методы могут манипулировать этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования. \n" +
                "\n" +
                "То есть: Инкапсуляция - это объединение данных и методов для работы с этими данными в одной упаковке («капсуле»).");
        core_1.add("- Свойство системы, которое позволяет описать новый класс на основе уже существующего с частичной или полностью заимствованной функциональностью.");
        core_1.add("- Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.\n" +
                "Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. А выбор какого-то конкретного действия, возлагается на компилятор языка программирования, в зависимости от ситуации. \n" +
                "Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).\n" +
                "Полиморфизм бывает динамическим (переопределение) и статическим (перегрузка). \n" +
                "Полиморфная переменная, это переменная, которая может принимать значения разных типов, а полиморфная функция, это функция у которой хотя бы один аргумент является полиморфной переменной. \n" +
                "Выделяют два вида полиморфных функций:\n" +
                "-ad hoc, функция ведет себя по разному для разных типов аргументов (например, функция draw() — рисует по разному фигуры разных типов);\n" +
                "-параметрическая функция ведет себя одинаково для аргументов разных типов (например, функция add() — одинаково кладет в контейнер элементы разных типов).");
        core_1.add(
                "- Есть два типа связи между объектами: 1) - ассоциация, которая делится на композицию и агрегацию. 2) - наследование. \n" +
                "\n" +
                "- Ассоциация - обозначает связь между обьектами. Например, игрок играет в определенной команде. \n" +
                "Ассоциация означает, что объекты двух классов могут ссылаться один на другой, иметь некоторую связь между друг другом. Например Менеджер может выписать Счет. \n" +
                "Соответственно возникает ассоциация между Менеджером и Счетом. \n" +
                "Еще пример — Преподаватель и Студент — т.е. какой-то Студент учится у какого-то Преподавателя. Ассоциация и есть описание связи между двумя объектами. Студент учится у Преподавателя. Идея достаточно простая — два объекта могут быть связаны между собой и это надо как-то описать.\n" +
                "-------------------------------------------------------------------------------------------------------------------------------------------------------------\n" +
                "- Композиция — еще более жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежат еще кому-то. \n" +
                "Например Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет быть в двух или трех машинах одновременно. \n" +
                "В отличии от студента, который может входить и в другие группы тоже. \n" +
                "\n" +
                "Например, класс автомобиля содержит объект класса электрического двигателя:\n" +
                "\n" +
                "public class ElectricEngine{ \n" +
                "\n" +
                "}\n" +
                " \n" +
                "\n" +
                "\n" +
                "public class Car {\n" +
                "    \n" +
                "\tElectricEngine engine;\n" +
                "    \n" +
                "\n" +
                "\tpublic Car()\n" +
                "    {\n" +
                "        \n" +
                "\t\tengine = new ElectricEngine();\n" +
                "    \n" +
                "\t}\n" +
                "\n" +
                "}\n" +
                "\n" +
                "При этом класс автомобиля полностью управляет жизненным циклом объекта двигателя. При уничтожении объекта автомобиля в области памяти вместе с ним будет уничтожен и объект двигателя. И в этом плане объект автомобиля является главным, а объект двигателя - зависимой.\n" +
                "-------------------------------------------------------------------------------------------------------------------------------------------------------------\n" +
                "- Агрегация определяет отношение Has a (англ. Имеет), но связь слабее чем в композиции, т.к. обьекты равноправны.\n");
        core_1.add("- Связывание есть наличие связи между вызываемым методом программы и написанным кодом.\n" +

                "Ранее свзязывание означает что - \n" +
                "если метод известен компилятору, то происходит ранее связывание на этапе компиляции (early binding), также называют статическим связыванием. \n" +

                "Позднее связывание (late binding) означает что - вызов метода возможен только во время выполнения, т.к. у компилятора нет информации, чтобы проверить корректность такого вызова. В java это возможно при помощи рефлексии. \n" +

                "Статическое связывание используется для final, перегруженных, приватных, статических методов. \n" +
                "А динамическое связывание используется для разрешения методам быть переопределенными. Все абстрактные методы реализуются при помощи динамического связывания.\n" +

                "При статическом связывании - используются не конкретные объекты, а информация о типе, то есть используется тип ссылочной переменной. \n" +
                "А при динамическом связывании, для нахождения нужного метода - используется конкретный объект.");
        core_1.add("- SOLID — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования. \n" +
                "\n" +
                "* S(Single Responsibility Principle) - принцип единственной ответственности - каждый класс выполняет лишь одну задачу. \n" +
                "Легкая модификация в будущем, простое тестирование, класс не имеет зависимостей на другие классы.\n" +
                "* O(Open Closed Principle) - принцип открытости/закрытости - программные сущности открыты для расширения и закрыты для модификации. \n" +
                "Чтобы не сломать логику в классе-родителе, мы унаследуемся от него и реализуем что-то своё, и используем свой класс.\n" +
                "* L(Liskov’s Substitution Principle) - принцип подстановки Барбары Лисков -  объекты в программе можно заменить их наследниками без изменения свойств программы.\n" +
                "* I(Interface Segregation Principle) - принцип разделения интерфейса - много специализированных интерфейсов лучше, чем один общий. \n" +
                "* D(Dependency Inversion Principle) - принцип инверсии зависимостей - зависимость на абстракциях. \n" +
                "Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.\n" +
                "Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. \n" +
                "\n" +
                "Эти принципы могут использоваться при создании интерфейсов и их реализаций. Например: терминал оплаты(абстракция) и разные карты оплаты.");
        core_1.add("- Написано однажды - работает везде!\n" +
                " Данная идея основывается в написании одного кода, который будет работать на любой платформе.");
        core_1.add("- Кроссплатформенность была достигнута за счёт создания виртуальной машина Java. \n" +
                "Java Virtual Machine или JVM - это программа, являющаяся прослойкой между операционной системой и Java программой. \n" +
                "В среде виртуальной машины выполняются коды Java программ. Сама JVM реализована для разных ОС.\n" +
                "И поэтому байт-код для JVM может исполняться везде где установлена JVM, и его не нужно перекомпилировать под каждую из платформ.");
        core_1.add("- Объектно-ориентированное программирование: Структура данных становится объектом, которым можно управлять для создания отношений между различными объектами.\n" +
                "- Язык высокого уровня с простым синтаксисом и плавной кривой обучения: Синтаксис Java основан на C ++, поэтому Java похожа на C. Тем не менее, синтаксис Java проще, что позволяет новичкам быстрее учиться и эффективнее использовать код для достижения конкретных результатов. \n" +
                "- Стандарт для корпоративных вычислительных систем\n" +
                ": Корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали искать надежные инструменты программирования, вместо языка C.\n" +
                "- Безопасность: Благодаря отсутсвию указателей и Security Manager (политика безопасности, в которой можно указать правила доступа, позволяет запускать приложения Java в \"песочнице\"). \n" +
                "- Независимость от платформы: Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на любой другой платформе, поддерживающей виртуальную машину Java (JVM). Таким образом, JVM служит уровнем абстракции между кодом и оборудованием.\n" +
                "- Язык для распределенного программирования и комфортной удаленной совместной работы\n" +
                ": Специфическая для Java методология распределенных вычислений называется Remote Method Invocation (RMI). RMI позволяет использовать все преимущества Java: безопасность, независимость от платформы и объектно-ориентированное программирование для распределенных вычислений. Кроме того, Java также поддерживает программирование сокетов и методологию распределения CORBA для обмена объектами между программами, написанными на разных языках.\n" +
                "- Автоматическое управление памятью: \n" +
                "Разработчикам Java не нужно вручную писать код для управления памятью благодаря \n" +
                "автоматическому управлению памятью (AMM). \n" +
                "- Многопоточность: \n" +
                "Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать время процессора, Java позволяет запускать потоки одновременно, что называется многопоточностью.\n" +
                "- Стабильность и сообщество: \n" +
                "Сообщество разработчиков Java не имеет себе равных. Около 45% респондентов опроса StackOverflow 2018 используют Java.");
        core_1.add("- Платное коммерческое использование (с 2019). \n" +
                "Низкая производительность \n" +
                "из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти.\n" +
                "- Не развитые инструменты по созданию GUI приложений на чистой java.\n" +
                "- Многословный код\n" +
                " Java — это более легкая версия неприступного C ++, которая вынуждает программистов прописывать свои действия словами из английского языка. Это делает язык более понятным для неспециалистов, но менее компактным.");
        core_1.add("- JDK (Java Development Kit) - включает JRE и набор инструментов разработчика приложений на языке Java: \n" +
                "* компилятор Java (javac). \n" +
                "* стандартные библиотеки классов java.\n" +
                "* примеры. \n" +
                "* документацию. \n" +
                "* различные утилиты.");
        core_1.add("- JRE (java Runtime Environment) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. \n" +
                "Состоит из JVM, ClassLoader(загрузчик классов, который динамически загружает классы Java в JVM) и стандартного набора библиотек и классов Java.");
        core_1.add("- JVM (Java Virtual Machine) - виртуальная машина Java, которая исполняет байт-код Java, (предварительно созданный из кода JIT компилятором) с помощью встроенного интерпретатора байткода. \n" +
                "HotSpot представляет собой реализацию концепции JVM.");
        core_1.add("- Байт-код Java — набор инструкций, скомпилированный компилятором, исполняемый JVM.");
        core_1.add("- Используется для передачи в JVM скомпилированного байт-кода, хранится в файлах с расширением .class. \n" +
                "При запуске JVM, используются три загрузчика классов: \n" +
                "* Bootstrap ClassLoader - базовый загрузчик\n" +
                " - загружает классы платформы JDK из архива rt.jar.  \n" +
                "* Extension ClassLoader - загрузчик расширений \n" +
                "- загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext. \n" +
                "* AppClassLoader - системный загрузчик \n" +
                "- загружает классы приложения, определенные в CLASSPATH. \n" +
                "ClassLoader выполняет три основных действия в строгом порядке: \n" +
                "• Загрузка: находит и импортирует двоичные данные для типа.\n" +
                "• Связывание: выполняет проверку, подготовку и (необязательно) разрешение.\n" +
                "  - Проверка: обеспечивает правильность импортируемого типа.\n" +
                "  - Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию.\n" +
                "  - Разрешение: преобразует символические ссылки из типа в прямые ссылки.\n" +
                "• Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями. \n" +
                "Каждый загрузчик хранит указатель на родительский, чтобы суметь передать загрузку если сам будет не в состоянии этого сделать.");
        core_1.add("- JIT (Just-in-time compilation) - компиляция на лету или динамическая компиляция. Это такая технология увеличения производительности программных систем, \n" +
                "путем компиляции байт-кода в машинный код, прямо во время работы программы. \n" +
                "В основном - отвечает за оптимизацию производительности приложений во время их выполнения.\n");
        core_1.add("- Сборщик мусора выполняет две задачи: \n" +
                "поиск мусора и очистку мусора.\n" +
                "Для обнаружения мусора есть два подхода:\n" +
                "- Учет(Подсчет) ссылок (Reference counting);\n" +
                "Это означает что - если обьект не имеет ссылок, он считается мусором.\n" +
                "Проблема заключается в том, что при таком подходе нет возможности выявить циклические ссылки, т.е. когда два обьекта не имеют внешних ссылок, но зато  ссылаются друг на друга. В следствии чего происходит -> утечка памяти.\n" +
                "- Трассировка (Tracing). (используется в HotSpot 6)  >> HotSpot - это одна из реализаций JVM.\n" +
                "Это означает что - до обьекта можно добраться из Корневых точек (GC root). \n" +
                "А до чего нельзя будет добраться - будет считаться мусором. \n" +
                ">> Корневые точки - это объекты или ссылки, которые создаются непосредственно в выполняемом коде.\n" +
                "И всё, что доступно из «живого»(используемого) объекта, также является «живым». (т.е., как я понял - живой объект это объект на который имеется ссылка).\n" +
                "Типы корневых точек (GC Roots) java приложения:\n" +
                "- объекты в статических полях классов\n" +
                "- объекты, доступные из стека потоков\n" +
                "- объекты из JNI(java native interface) ссылок в native методах.\n" +
                "Существует 4 типа корневых точки: \n" +
                "• Локальные переменные и параметры методов; \n" +
                "• Потоки; \n" +
                "• Статические переменные; \n" +
                "• Ссылки из JNI. \n" +
                "Самое простое java приложение будет иметь следующие корневые точки: \n" +
                "• Локальные переменные внутри метода main(), и параметры метода main(); \n" +
                "• Поток который выполняет метод main(); \n" +
                "• Статические переменные класса, внутри которого находится метод main(). \n" +
                "Процессы сборки мусора разделяются на несколько видов: \n" +
                "* minor GC (малая) - частая и быстрая сборка мусора. Работает только с областью памяти \"Young generation\". \n" +
                "- приложение приостанавливается на начало сборки мусора (такие остановки называются stop-the-world);\n" +
                "  - «живые» объекты из Eden перемещаются в область памяти «To Space» (или как я понял в Survival Space);\n" +
                "  - «живые» объекты из «From Space» перемещаются в «To Space» или в «Old generation», если они достаточно «старые»;\n" +
                "  - Eden и «From Space» очищаются от мусора;\n" +
                "  - «To Space» и «From Space» меняются местами; \n" +
                "- приложение возобновляет работу.  \n" +
                "* major GC (старшая) - редкий и более длительный, затрагивает объекты старшего поколения. \n" +
                "В принцип работы «major GC» добавляется специальная процедура «уплотнения», позволяющая более эффективно использовать память. \n" +
                "И в этой процедуре живые объекты перемещаются в начало. Таким образом, мусор остается в конце памяти. \n" +
                "* full GC (полная) -  полный сборщик мусора сначала запускает Minor, а затем Major (хотя порядок может быть изменен, если старое поколение заполнено, и в этом случае он освобождается первым, чтобы позволить ему получать объекты от молодого поколения).\n" +
                ">> По информации из сайта JavaRush. Куча, где хранятся все созданные объекты, делится на несколько частей: \n" +
                ">> Yung Generation и Old Generation.\n" +
                ">> Yung Generation - делится на Eden(Райский сад) и Survival Space(Место для выжиыших). Survival Space делится на 5 разделов для каждого поколения.");
        core_1.add("- Память процесса делится на Stack (стек) и Heap (куча) : \n" +
                "* Stack содержит staсk-frame'ы, которые делятся на три части: параметры метода, указатель на предыдущий фрейм и локальные переменные. \n" +
                "* Структура Heap будет зависеть от выбранного сборщика мусора.\n" +
                "- Размер памяти стека, меньше памяти кучи. Стековая память быстрее памяти кучи.\n" +
                "- Heap - используется всем приложением, Stack - одним потоком исполняемой программы.\n" +
                "- Обьекты в куче доступны из любого места программы, стековая память не доступна для других потоков. \n" +
                "- Новый обьект создается в heap, в stack размещается ссылка на него. В стеке обычно размещаются локальные переменные примитивных типов. \n" +
                "- Если память стека закончилась JRE вызовет исключение StackOverflowError, если куча заполнена OutOfMemoryError.\n" +
                "- В куче есть ссылки между объектами и их классами. На этом основана рефлексия. \n" +
                "Обе области хранятся в RAM. \n" +
                "С помощью опций Xms и Xmx можно настроить начальный и максимально допустимый размер кучи соответственно. Также существуют опции для настройки величины стека.");
        core_1.add("- Целочисленные, Вещественные, Логические и Строковые. \n" +
                "* byte   = 8 бит  , от -128 до 127\n" +
                "* short  = 16 бит , от -32768 до 32767 \n" +
                "* int    = 32 бит , от -2147483648 до 2147483647\n" +
                "* long   = 64 бит , от -9223372036854775808L до 9223372036854775807L\n" +
                "* float  = 32 бит , от 1.4e-45f до 3.4e+38f\n" +
                "* double = 64 бит , от 4.9e-324 до 1.7e+308 \n" +
                "* char\n" +
                "   = 16 бит , от 0 до 65536\n" +
                "* boolean = 8 бит в массиве, и 32 бита в остальных случаях.");
        core_1.add("- 16-разрядное беззнаковое целое, представляющее собой символ UTF-16 (буквы и цифры)");
        core_1.add("- Это зависит от реализации JVM. \n" +
                "В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int. \n" +
                "Однако, в определенных версия JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту.\n");
        core_1.add("- Обертка — это специальный класс, который хранит внутри себя значение примитива(объекты классов-оберток являются неизменяемыми (Immutable)). \n" +
                "Нужны для реализации дженериков.\n" +
                "Классы-обёртки были придуманы для того, чтобы иметь возможность оперировать с простыми числами (и boolean) как с объектами.");
        core_1.add("- Автоупаковка - это преобразование примитивных типов в эквивалентные объекты. \n" +
                "- Автораспаковка - это преобразование объектов в соответствующие им примитивные типы.\n" +
                "Для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется ничего делать, все происходит автоматически.\n");
        core_1.add("- Неявное приведение - автоматическое расширение типа переменной от меньшего к большему. \n" +
                "- Явное приведение - явное сужение от большего к меньшему. Необходимо явно указать сужаемый тип.\n" +
                "В случае с объектами мы можем делать неявное(автоматическое) приведение от наследника к родителю, но не наоборот, иначе получим ClassCastException.");
        core_1.add("- В Java есть пул(pool) целых чисел в промежутке [-128;127], так как это самый часто вречающийся диапазон. \n" +
                "Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула.\n" +
                " ");
        core_1.add("- Класс String в Java - является неизменяемым из-за модификатора final и отсутствия сеттера. Это нужно для реализации пула стрингов. \n" +
                "При редактировании будет создаваться новая строка. При копировании новая строка не создается, а создается ссылка на существующую строку.");
        core_1.add("- Пул строк это - область памяти где хранятся обьекты строк. \n" +
                "При создании в пуле идет поиск строки: \n" +
                "- если НЕ находит -  то создается строка, и возращается ссылка\n" +
                "- если находит - то возращает ссылку найденной строки. \n" +
                "При этом использование оператора new заставляет класс String создать новый объект, даже если такая строка уже есть в пуле. \n" +
                "После этого можем использовать метод intern(), чтобы поместить этот объект в пул строк. \n" +
                "Пул строк и Integer хранятся в Heap-е, но ссылки на объекты хранятся в stack.");
        core_1.add("- Т.к. строка неизменяемый класс, то будет большое потребление ресурсов при редактировании. \n" +
                "- Т.к. каждую итерацию при редактировании будет создаваться новый обьект строки. \n" +
                "Рекомендуется использовать StringBuilder или StringBuffer. ");
        core_1.add("- 1. Пул строк. \n" +
                "Так как строки в Java хранятся в пуле строк, то ваш пароль в виде обычного текста будет доступен в памяти, пока сборщик мусора не очистит её. \n" +
                "И поскольку String используются в String pool для повторного использования, существует довольно высокая вероятность того, что пароль останется в памяти надолго, что совсем не безопасно. \n" +
                "- 2. Рекомендации авторов. \n" +
                "Java сама по себе рекомендует использовать метод getPassword () из класса JPasswordField, который возвращает char [].\n" +
                "- 3. Случайная печать в логах. \n" +
                "С типом String всегда существует опасность того, что текст, хранящийся в строке будет напечатан в файле логов или в консоли. \n" +
                "В то же время в случае использования Array, вы не будете печатать содержимое массива, а только его расположение в памяти.");
        core_1.add("- 1. Для возможности реализации строкового пула (String pool). \n" +
                "Виртуальная машина имеет возможность сохранить много места в памяти (heap space) т.к. разные строковые переменные указывают на одну переменную в пуле. \n" +
                "При изменяемости строк было бы невозможно реализовать интернирование, поскольку если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку. \n" +
                "- 2. Безопасность. \n" +
                "Изменяемость строк несло бы в себе потенциальную угрозу безопасности приложения. Поскольку в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. — неизменяемость позволяет избежать проблем с доступом.\n" +
                "- 3. Для многопоточности. Неизменяемые строки потокобезопасны. \n" +
                "Так как строка неизменяемая то, она безопасна для много поточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности. Таким образом, строки в Java полностью потокобезопасны. \n" +
                "4. Ключ для HashMap. \n" +
                "Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет никакой необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Поэтому строка наиболее часто используется в качестве ключа HashMap. \n" +
                "В итоге: \n" +
                "- можно передавать строку между потоками не опасаясь, что она будет изменена.\n" +
                "- отсутствуют проблемы с синхронизацией потоков\n" +
                "- отсутствие проблем с  утечкой памяти\n" +
                "- отсутствие проблем с доступом и безопасностью при использовании строк для передачи параметров авторизации, открытия файлов и т.д. \n" +
                "- кэширование hashcode\n" +
                "- экономия памяти при использовании пула строк для хранения повторяющихся строк.");
        core_1.add("- Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета.");
        core_1.add("- Помещает строку в pool строк. (Например, если мы создали новую строку с помощью оператора new).");
        core_1.add("- Да, начиная с Java 7 в операторе switch можно использовать строки, ранние версии Java не поддерживают этого. \n" +
                "При этом:\n" +
                "- участвующие строки чувствительны к регистру; \n" +
                "- использование строк в конструкции switch делает код читабельнее, убирая множественные цепи условий if-else\n" +
                "- оператор switch использует метод String.equals() для сравнения полученного значения со значениями case, поэтому добавьте проверку на NULL во избежание NullPointerException.");
        core_1.add("- String - неизменяемый, потокобезопасный;\n" +
                "- StringBuffer - изменяемый, потокобезопасный; \n" +
                "StringBuilder - изменяемый, потоконебезопасный.");
        core_1.add("- Многомерные массивы в их классическом понимании в java не существуют.\n" +
                " Многомерный массив всегда прямоугольный и неразрывен в памяти. \n" +
                "А то, что в java считается мнгомерным - в других языках ещё называют \"зубчатым массивом\" или массивом массивов.");
        core_1.add("- byte    = 0\n" +
                "- short   = 0\n" +
                "- int     = 0;\n" +
                "long    = 0L\n" +
                "- float   = 0.0f; \n" +
                "- double  = 0.0d; \n" +
                "- char    = '\\u0000'; \n" +
                "- boolean = false\n" +
                "- Обьекты = null\n" +
                "Локальные (в методе) переменные не имеют значений по умолчанию, их имеют только поля класса. \n" +
                "Не static-поле класса будет инициализировано после того, как будет создан объект этого класса. \n" +
                "А  static-поле будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной. ");
        core_1.add("- Это имя метода плюс параметры (порядок параметров имеет значение из-за множественной передачи данных через троеточие, которое должно располагаться последним). \n" +
                "В сигнатуру метода не входит возвращаемое значение, и не входит бросаемые им исключения. \n" +
                "А сигнатура метода в сочетании с типом возвращаемого значения и бросаемыми исключениями называется контрактом метода.");
        core_1.add("- Является, как правило, точкой входа в программу и вызывается JVM. \n" +
                "Как только заканчивается выполнение метода main(), так сразу же завершается работа самой программы. \n" +
                "static - чтобы JVM смогла загрузить его во время компиляции. \n" +
                "public static void и сигнатура - это обязательное декларирование. \n" +
                "Мэйнов может быть много и может не быть вообще. \n" +
                "Также может быть перегружен.");
        core_1.add("- Java передает параметры по значению. Всегда. \n" +
                "С примитивами, мы получаем копию содержимого. Со ссылками мы тоже получаем копию ссылки.\n" +
                "\n");
        core_1.add("- 1. Вложенные(Nested) классы – нестатические классы внутри внешнего класса.\n" +
                "- 2. Вложенные(Nested) статические классы – статические классы внутри внешнего класса. \n" +
                "3. Локальные классы Java – классы внутри методов. Есть разница между локальным и внутреним. \n" +
                "4. Анонимные Java классы – классы, которые создаются на ходу. Анонимные классы доступно\n" +
                "- 5. Final, abstract, enum - классы.\n" +
                "К классам верхнего уровня модификатор static неприменим. ");
        core_1.add("- Вложенные классы нужны для обслуживания внешних классов. \n" +
                "1. Статические вложенные классы (Static nested classes). \n" +
                "- Есть возможность обращения к внутренним статическим полям и методам класса обертки. \n" +
                "2. Вложенные классы\n" +
                "- Есть возможность обращения к внутренним полям и методам класса обертки.\n" +
                "- Не может иметь статических объявлений.\n" +
                "- Внутри такого класса нельзя объявить перечисления. \n" +
                "- Если нужно явно получить this внешнего класса — OuterClass.this; \n" +
                "3. Локальный класс. \n" +
                "- Видны только в пределах блока, в котором объявлены.\n" +
                "- Не могут быть объявлены как private/public/protected или static (по этой причине интерфейсы нельзя объявить локально).\n" +
                "- Не могут иметь внутри себя статических объявлений (полей, методов, классов), но могут иметь константы (static final). \n" +
                "Имеют доступ к полям и методам обрамляющего класса. \n" +
                "- Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final или являются effectively final. \n" +
                "4. Анонимные классы\n" +
                "- Локальный класс без имени.");
        core_1.add("- Данные классы объявляются внутри других методов. Они обладают всеми свойствами нестатического вложенного класса, но только создавать их экземпляры можно только внутри метода. \n" +
                "Особенности:\n" +
                "- Локальные классы способны работать только с final переменными метода. \n" +
                "- С 8+ версий Java можно использовать не final переменные в локальных классах, но только при условии, что они не будут изменяться.\n" +
                "- Локальные классы нельзя объявлять с модификаторами доступа. \n" +
                "Локальные классы обладают доступом к переменным метода. \n" +
                "Может быть создан внутри блоков инициализации.");
        core_1.add("- Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. \n" +
                "Создание экземпляра анонимного класса происходит одновременно с его объявлением. \n" +
                "В зависимости от местоположения анонимный класс может вести себя как статический либо как нестатический вложенный класс.\n" +
                "Анонимные классы имеют несколько ограничений:\n" +
                "- Их использование разрешено только в одном месте программы - месте его создания;\n" +
                "- Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться; \n" +
                "Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять новых методов, так как для доступа к ним нет поименованного типа. \n" +
                "Анонимные классы обычно применяются для: \n" +
                "  * создания объекта функции (function object), например реализация интерфейса Comparator;\n" +
                "  * создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;\n" +
                "  * в статическом методе генерации;\n" +
                "  * инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.\n" +
                "- Анонимные классы всегда являются конечными классами. \n" +
                "Каждое объявление анонимного класса уникально. \n" +
                "- Видны только внутри того метода, в котором определены. \n" +
                "В документации Oracle приведена хорошая рекомендация: «Применяйте анонимные классы, если вам нужен локальный класс для одноразового использования». ");
        core_1.add("- Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса. \n" +
                "- Простой вложенный класс, может обратиться к любому полю внешнего класса напрямую. \n" +
                "В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к внешнему полю следует через имя внешнего класса. \n" +
                "Например: Outer.this.field.");
        core_1.add("- Перечисления(Enum) - это набор логически связанных констант. \n" +
                "Перечисление фактически представляет новый класс, поэтому мы можем определить переменную данного типа и использовать ее.\n" +
                "Перечисления, как и обычные классы, могут определять конструкторы, поля и методы. \n" +
                "Следует отметить, что конструктор по умолчанию приватный. \n" +
                "Также можно определять методы для отдельных констант. \n" +
                "Методы:\n" +
                "- ordinal() возвращает порядковый номер определенной константы (нумерация начинается с 0).\n" +
                "- values() возвращает массив всех констант перечисления. \n" +
                "Еnum имеет ряд преимуществ при использовании в сравнении с static final int. \n" +
                "Главным отличием является то что используя enum вы можете проверить тип данных. \n" +
                "Недостатки\n" +
                "- К ним не применимы операторы >, <, >=, <=\n" +
                "- Еnum также требует больше памяти для хранения чем обычная константа. \n" +
                "Нужны для ограничения области допустимых значений: например, времена года, дни недели.");
        core_1.add("- В Java нет поддержки множественного наследования классов.\n" +
                "Предположим, что SuperClass — это абстрактный класс, описывающий некоторый метод, а классы ClassA и ClassB — обычные классы наследники SuperClass, \n" +
                "а класс ClassC наследуется от ClassA и ClassB одновременно. \n" +
                "Вызов метода родительского класса приведет к неопределенности, так как компилятор не знает о том, метод какого именно суперкласса должен быть вызван. \n" +
                "Это и есть основная причина, почему в Java нет поддержки множественного наследования классов.\n" +
                ">> В Java множественное наследование не поддерживается в классах, но оно поддерживается в интерфейсах. И один интерфейс может расширять множество других >> интерфейсов. \n" +
                "1. Классы всегда побеждают: Определенный в классе / суперклассе метод всегда имеет высший приоритет перед дефолтными методами интерфейсов. \n" +
                "2. Если не срабатывает правило 1, то побеждают саб-интерфейсы (more specific). Т.е. если интерфейс B наследует A, и у обоих есть методы с одинаковой сигнатурой, то побеждает B. \n" +
                "3. Если оба правила не работают, то класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать, иначе компилятор будет сильно материться.");
        core_1.add("- Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый «конструктор по умолчанию».\n" +
                "Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создаваться не будет и, если он необходим, его нужно описывать явно.\n" +
                ">> А зачем нужен этот конструктор по умолчанию и без параметров?\n" +
                ">> Создавая объект посредством конструктора без параметра, вы просто инициализируете его поля и выделяете память под этот объект. То-есть в памяти у вас появится ссылка на этот объект, но о нем ничего пока не известно.");
        core_1.add("- Да, могут. Приватный конструктор запрещает создание экземпляра класса вне методов самого класса. \n" +
                "Нужен для реализации паттернов, например singleton.");
        core_1.add("- При запуске JVM, используются три загрузчика классов: \n" +
                "* Bootstrap ClassLoader - главный загрузчик\n" +
                " - загружает платформенные классы JDK из архива rt.jar\n" +
                "* AppClassLoader - системный загрузчик\n" +
                " - загружает классы приложения, определенные в CLASSPATH. \n" +
                "* Extension ClassLoader - загрузчик расширений \n" +
                "- загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext. \n" +
                "Динамическая загрузка происходит \"на лету\" в ходе выполнения программы с помощью статического метода класса Class.forName(имя класса). \n" +
                "Для чего нужна динамическая загрузка? \n" +
                "- Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().");
        core_1.add("- У конструктора по умолчанию отсутствуют какие-либо аргументы. \n" +
                "- Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона.\n" +
                "- Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).");
        core_1.add("- Private – доступ к компоненту только из этого класса, в котором объявлен. \n" +
                "- Default – Переменная или метод будут доступны для любого другого класса в том же пакете. \n" +
                "- Protected – Поля protected доступны всем классам внутри пакета, а также всем классам-наследникам вне пакета. \n" +
                "- Public – доступ к компоненту из экземпляра любого класса и любого пакета. \n" +
                "Класс может быть объявлен с модификатором public и default. // Хотя я пробовал объявлять класс дефолтным - компилятор ругается.");
        core_1.add("- Модификатор static в Java напрямую связан с классом. \n" +
                "Если поле статично, значит оно принадлежит классу, если метод статичный — аналогично: он принадлежит классу. \n" +
                "Исходя из этого, можно обращаться к статическому методу или полю, используя имя класса. \n" +
                "Например, если поле count статично в классе Counter, значит, вы можете обратиться к переменной запросом вида: Counter.count. ");
        core_1.add("- Нет. Нельзя переопределять статические методы. \n" +
                "Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса  вместо переопределения. Это явление известно как сокрытие методов (hiding methods). \n" +
                "Перегружен - да, может. \n" +
                "Всё работает точно так же как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.");
        core_1.add("- Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.");
        core_1.add("- Сузить нельзя. При переопределении метода нельзя сузить модификатор доступа к методу (например, с public до private), НО МОЖНО РАСШИРИТЬ. \n" +
                "- Изменить тип возвращаемого значения нельзя, но можно сузить возвращаемое значение, но только если они совместимы. \n" +
                "Например, если метод возвращает объект класса, а переопределенный метод возвращает объект класса-наследника.");
        core_1.add("- В сигнатуре(имя + параметры) менять ничего нельзя.\n" +
                "Возможно расширение уровня доступа. \n" +
                "Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).\n" +
                "Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. \n" +
                "Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. \n" +
                "Порядок следования таких элементов при переопределении значения не имеет.");
        core_1.add("- Класс можно объявить статическим за исключением классов верхнего уровня.\n" +
                "Такие классы известны как «вложенные статические классы» (nested static class). ");
        core_1.add("- Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование. \n" +
                "Следует также отметить, что к abstract-классам нельзя применить модификатор final, т.к. это взаимоисключающие понятия. \n" +
                "Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено. \n" +
                "Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект. \n" +
                "Важно: Ссылку изменить нельзя, но состояние объекта изменять можно.\n" +
                "Т.к. массив – это объект, то final означает, что после присвоения ссылки на объект, уже нельзя ее изменить, но можно изменять состояние объекта.\n");
        core_1.add("- Абстрактным называется класс, на основе которого не могут создаваться объекты. Это \n" +
                "как обычный класс, но с абстрактными методами. \n" +
                "Нельзя создать объект или экземпляр абстрактного класса. \n" +
                "Наследниками абстрактного класса могут быть другие абстрактные классы.");
        core_1.add("- Класс может быть абстрактным без единого абстрактного метода, если у него указан модификатор abstract.");
        core_1.add("- Да. Необходимы для наследников. \n" +
                "В абстрактном классе в Java можно объявить и определить конструкторы. \n" +
                "Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов. \n" +
                "Абстрактные конструкторы будут часто использоваться для обеспечения ограничений класса или инвариантов, таких как минимальные поля, \n" +
                "необходимые для настройки класса.");
        core_1.add("- Интерфейс — это план класса или, можно сказать, набор абстрактных методов и статических констант. \n" +
                "В интерфейсе каждый метод является открытым и абстрактным, но не содержит конструктора. \n" +
                "Таким образом, интерфейс в основном представляет собой группу связанных методов с пустыми телами. \n" +
                "Другими словами, интерфейс определяет как элементы будут взаимодействовать между собой. \n" +
                "- методы интерфейса являются публичными (public) и абстрактными (abstract), \n" +
                "- поля — public static final. ");
        core_1.add("- 1. Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (кроме public static final), \n" +
                "в то время как у абстрактного класса они могут быть.\n" +
                "- 2. Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно. Интерфейс может наследовать (extends) другой интерфейс/интерфейсы. \n" +
                "- 3. Абстрактные классы используются, когда есть отношение \"is-a\", то есть когда класс-наследник расширяет базовый абстрактный класс, \n" +
                "а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом.\n" +
                "4. Абстрактный класс может реализовывать методы; интерфейс может реализовывать дефолтные методы начиная с 8-й версии Java.\n" +
                "\n");
        core_1.add("- Да, может. Используется ключевое слово extends.");
        core_1.add("- В JDK-8 была добавлена такая функциональность как методы по умолчанию с модификатором default. \n" +
                "И теперь интерфейсы могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. \n" +
                "Это нужно для обратной совместимости. \n" +
                "(Если один или несколько методов добавляются к интерфейсу, все реализации также будут вынуждены их реализовывать. Методы интерфейса по умолчанию являются эффективным способом решения этой проблемы).");
        core_1.add("- Класс, наследующий конфликтующие интерфейсы, должен явно через кл. слово super определить, какой именно метод вызвать:\n" +
                " InterfaceB.super.method();");
        core_1.add("- 1. Статические блоки от первого до последнего предка(от предка до наследника). \n" +
                "- 2. Попарно динамической блок инициализации и конструктор от первого до последнего предка.");
        core_1.add("- Инициализация - это когда мы впервые задаем переменной какое-либо значение. \n" +
                "Существуют статические и нестатические блоки инициализации.\n");
        core_1.add("- Статические блоки инициализации используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент предшествующий созданию объектов этого класса при помощи конструктора. Такой блок принадлежит только самому классу.");
        core_1.add("- Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом, требуется, чтобы объявления этих исключений были \n" +
                "перечислены в throws всех конструкторов класса. Иначе будет ошибка компиляции. \n" +
                "- Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.");
        core_1.add("- Если возникшее исключение - наследник RuntimeException:\n" +
                "  * для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;\n" +
                "* для нестатических будет проброшено исключение-источник.\n" +
                "- Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error.\n" +
                "- Если исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое исключение выброшено не будет.");
        core_1.add("- Базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы. \n" +
                "Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. В результате объект Object может ссылаться на объект любого другого класса.\n" +
                "Рефлексия (от позднелат. reflexio - обращение назад) - это механизм исследования данных о программе во время её выполнения.");
        core_1.add("- equals() - проверка на равенство двух обьектов\n" +
                "- hashCode() - изначально случайно число int\n" +
                "- toString() - представления данного объекта в виде строки.\n" +
                "- getClass() - получение типа данного обьекта. \n" +
                "- clone() -  клонирует объект методом. \n" +
                "- finalize() - deprecated, вызывается GC перед удалением. (нет гарантии что будет вызван)\n" +
                "А так-же для многопоточки: \n" +
                "wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify(). \n" +
                "notify(): продолжает работу потока, у которого ранее был вызван метод wait(). \n" +
                "notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait(). \n" +
                "- wait(long timeOut) - нить освобождает монитор и «становится на паузу», принимает максимальное время ожидания в миллисекундах.\n" +
                "- wait(long timeOut, int nanos) - нить освобождает монитор и «становится на паузу», принимает максимальное время ожидания в миллисекундах, дополнительное время, в диапазоне наносекунд 0-999999.");
        core_1.add("- Хеш-код — это целочисленный результат работы метода, которому в качестве входного параметра передан объект.\n" +
                "Если более точно, то это битовая строка фиксированной длины, полученная из массива произвольной длины. \n" +
                "Equals - это метод, определенный в Object, который служит для сравнения объектов. При сравнении объектов при помощи == идет сравнение по ссылкам. \n" +
                "При сравнении по equals() идет сравнение по состояниям объектов. \n" +
                "Свойства equals():\n" +
                "• Симметричность: Для двух ссылок, a и b, a.equals(b) тогда и только тогда, когда b.equals(a)\n" +
                "• Рефлексивность: Для любого заданного значения x, выражение x.equals(x) должно возвращать true.\n" +
                " Для заданного — имеется в виду такого, что x != null. \n" +
                "• Постоянство: Повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено.\n" +
                "• Транзитивность: Если a.equals(b) и b.equals(c), то тогда a.equals(c)\n" +
                "• Совместимость с hashCode(): Два тождественно равных объекта должны иметь одно и то же значение hashCode(). \n" +
                "При переопределении equals() обязательно нужно переопределить метод hashCode(). Равные объекты должны возвращать одинаковые хэш коды.\n");
        core_1.add("- 1). Реализация метода Object.equals() сводится к проверке на равенство двух ссылок: \n" +
                "public boolean equals(Object obj) {\n" +
                "\treturn (this == obj);\n" +
                "- 2) HashCode реализован таким образом, что для одного и того же входного объекта, хеш-код всегда будет одинаковым. \n" +
                "Реализация метода Object.hashCode() описана как native, т.е. написана не на Java. \n" +
                "Непереопределенный hashCode возвращает идентификационный хеш, основанный на состоянии потока, объединённого с xorshift (в OpenJDK8). \n" +
                "А вообще, функция предлагает шесть методов на базе значения переменной hashCode.\n" +
                "0. Случайно сгенерированное число.\n" +
                "1. Функция адреса объекта в памяти. \n" +
                "2. Жёстко запрограммированное значение 1 (используется при тестировании на чувствительность (sensitivity testing)).\n" +
                "3. Последовательность. \n" +
                "4. Адрес объекта в памяти, приведённый к целочисленному значению. \n" +
                "5. Состояние потока, объединённое с xorshift:                        public native int hashCode(); \n" +
                "Ситуация, когда у разных объектов одинаковые хеш-коды называется — коллизией. \n" +
                "Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.");
        core_1.add("- equals() - сравнение по состоянию, == - по ссылкам.");
        core_1.add("- 1. Проверить на равенство ссылки объектов this и параметра метода o.\n" +
                " if (this == o) return true;\n" +
                "- 2. Проверить, определена ли ссылка o, т. е. является ли она null. \n" +
                "Если в дальнейшем при сравнении типов объектов будет использоваться оператор instanceof, этот пункт можно пропустить, т. к. этот параметр возвращает false в данном случае null instanceof Object.\n" +
                "- 3. Сравнить типы объектов this и o с помощью оператора instanceof или метода getClass(), руководствуясь описанием выше и собственным чутьем. \n" +
                "- 4. Если метод equals переопределяется в подклассе, не забудьте сделать вызов super.equals(o). \n" +
                "- 5. Выполнить преобразование типа параметра o к требуемому классу.\n" +
                "- 6. Выполнить сравнение всех значимых полей объектов: \n" +
                "     * для примитивных типов (кроме float и double), используя оператор ==\n" +
                "     * для ссылочных полей необходимо вызвать их метод equals\n" +
                "     * для массивов можно воспользоваться перебором по циклу, либо методом Arrays.equals(o)        \n" +
                "     * для типов float и double необходимо использовать методы сравнения соответствующих оберточных классов Float.compare() и Double.compare()\n" +
                "Пример кода: \n" +
                "\n" +
                "    @Override\n" +
                "    public boolean equals(Object o) {\n" +
                "        if (this == o) return true;\n" +
                "        if (o == null || getClass() != o.getClass()) return false;\n" +
                "        Snake snake = (Snake) o;\n" +
                "        return age == snake.age && Objects.equals(name, snake.name);\n" +
                "    }\n" +
                "\n" +
                "    @Override\n" +
                "    public int hashCode() {\n" +
                "        return Objects.hash(age, name);\n" +
                "    }");
        core_1.add("- Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать. \n" +
                "Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.");
        core_1.add("- 1) Если два объекта возвращают разные значения hashcode(), то они не могут быть равны\n" +
                "- 2) Если equals объектов true, то и хэшкоды должны быть равны.  \n" +
                "- 3) Переопределив equals, всегда переопределять и hashcode.");
        core_1.add("- вычисляет целочисленное значение для конкретного элемента класса, чтобы использовать его для быстрого поиска и доступа к этому элементу в hash-структурах данных, например, HashMap, HashSet и прочих.");
        core_1.add("- Если хеш-коды разные, то и входные объекты гарантированно разные.\n" +
                "- Если хеш-коды равны, то входные объекты не всегда равны.\n" +
                " При вычислении хэш-кода следует использовать те же поля, которые сравниваются в equals и которые не вычисляются на основе других значений.\n" +
                "- вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.\n" +
                "- вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true). \n" +
                "- вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.");
        core_1.add("- Выбирать поля, которые с большой долью вероятности будут различаться. \n" +
                "Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как id, uuid. \n" +
                "При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().\n");
        core_1.add("- Когда у разных объектов одинаковые хеш-коды называется — коллизией.");
        core_1.add("- В Java множество возможных хэш-кодов ограничено типом int, а множество объектов ничем не ограничено. \n" +
                "Из-за этого, вполне возможна ситуация, что хэш-коды разных объектов могут совпасть.");
        core_1.add("- Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию.");
        core_1.add("- getClass() получает только класс, а оператор instanceof проверяет является ли объект экземпляром класса или его потомком.");
        core_1.add("- Исключение — это ошибка (является объектом), возникающая во время выполнения программы. ");
        core_1.add("- 1. класс Throwable (checked).\n" +
                "- 2. от Throwable  -> Error (ошибки JVM) и Exception (checked общие)\n" +
                "- 3. от Exception \n" +
                " -> RuntimeException (unchecked)\n" +
                "     - > IOException, SQLException, ReflectiveOperationException (checked)\n" +
                "- 4. RuntimeException (unchecked):\n" +
                "  ClassCastExceptiuon\n" +
                "  IndexOutOfBoundException\n" +
                "  AritthmeticException\n" +
                "  NullPointerException\n" +
                "checked - зависит от программиста, unchecked - от программиста не зависит.");
        core_1.add("- 1. Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. \n" +
                "Unchecked могут не обрабатываться и не быть описанными.\n" +
                "- 2. Unchecked исключения в Java — наследованные от RuntimeException, checked — от Exception. \n" +
                "Checked исключения отличаются от Unchecked исключения в Java, тем что\n" +
                " Checked исключения проверяются компилятором на этапе компиляции. \n" +
                "А Unchecked исключения происходит на этапе выполнения.\n");
        core_1.add("- Можно, чтобы в некотрых случаях программа не прекратила работу.");
        core_1.add("- Throw");
        core_1.add("- Метод потенциально может выбросить исключение с указанным типом. \n" +
                "Передаёт обработку исключения вышестоящему методу.");
        core_1.add("- Необходимо унаследоваться от базового класса требуемого типа исключений (например, от Exception или RuntimeException), и переопределить методы.");
        core_1.add("- Try - блок в котором может появиться исключение; \n" +
                "- Catch - блок в котором мы указываем исключение и логику его обработки; \n" +
                "- Finally - блок который обязательно отработает.");
        core_1.add("- try может быть в паре с finally, без catch. Работает это точно так же - после выхода из блока try выполняется блок finally.");
        core_1.add("- Да");
        core_1.add("- Да, кроме случаев завершения работы программы или JVM: \n" +
                "1 - Finally может не выполниться в случае если в блоке try вызывает System.exit(0), \n" +
                "2 - Runtime.getRuntime().exit(0), Runtime.getRuntime().halt(0) и если во время исполнения блока try виртуальная машина выполнила недопустимую операцию и будет закрыта. \n" +
                "3 - В блоке try{} бесконечный цикл.");
        core_1.add("- Может. И оно будет передано в виртуальную машину Java (JVM).\n" +
                "Для случая с методом main произойдет две вещи: \n" +
                "- будет завершен главный поток приложения; \n" +
                "- будет вызван ThreadGroup.uncaughtException.");
        core_1.add("- От наследника к предку.");
        core_1.add("- Дает возможность объявлять один или несколько ресурсов в блоке try, которые будут закрыты автоматически без использования finally блока. \n" +
                "В качестве ресурса можно использовать любой объект, класс которого реализует интерфейс java.lang.AutoCloseable или java.io.Closeable.\n" +
                ">>> Closeable это наследник AutoCloseable.");
        core_1.add( "- finally-секция может «перебить» throw/return при помощи другого throw/return.");
        core_1.add("- В try-with-resources добавленна возможность хранения \"подавленных\" исключений, и брошенное try-блоком исключение имеет больший приоритет, чем исключения получившиеся во время закрытия.");
        core_1.add("- Сериализация это процесс сохранения состояния объекта в последовательность байт;  \n" +
                "Реализована через интерфейс - маркер Serializable. ");
        core_1.add("- Для компактного сохранения состояния объекта и считывание этого состояния.");
        core_1.add("Процесс сериализации:\n" +
                "- 1) Класс сериализуемого объекта должен реализовывать интерфейс Serializable\n" +
                "- 2) Создать поток ObjectOutputStream (oos), который записывает объект в переданный OutputStream.\n" +
                "- 3) Записать в поток: oos.writeObject(Object); \n" +
                "- 4) Сделать oos.flush() и oos.close().\n" +
                "Для сериализации объектов в поток используется класс ObjectOutputStream. Он записывает данные в поток.  \n" +
                "void writeObject(Object obj): записывает в поток отдельный объект. \n" +
                "void close(): закрывает поток. \n" +
                "void flush(): очищает буфер и сбрасывает его содержимое в выходной поток. \n" +
                "Для десериализации – ObjectInputStream. \n" +
                "Object readObject(): считывает из потока объект. \n" +
                "void close(): закрывает поток. ");
        core_1.add("- Использовать интерфейс Externalizable. \n" +
                "- Переопределить методы:\n" +
                "  * writeExternal(ObjectOutput out) throws IOException\n" +
                "  * readExternal(ObjectInput in) throws IOException, ClassNotFoundException;");
        core_1.add("- 1) Добавить к полю модификатор transient. В таком случае после восстановления его значение будет null.\n" +
                "- 2) Сделать поле static. Значения статических полей автоматически не сохраняются. \n" +
                "- 3) Поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании Externalizable, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в readExternal изменить значение этого поля будет невозможно. \n" +
                "Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.");
        core_1.add("- Для создания собственного протокола нужно просто переопределить writeExternal() и readExternal(). \n" +
                "В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках. ");
        core_1.add("- Поле private static final long serialVersionUID - содержит уникальный идентификатор версии сериализованного класса. \n" +
                "Оно вычисляется по содержимому класса - полям, их порядку объявления, методам, их порядку объявления. \n" +
                "Соответственно, при любом изменении в классе это поле поменяет свое значение.\n" +
                " Если мы не объявляем его явно, Java делает это за нас.");
        core_1.add("- Вы должны изменить serialVersionUID только тогда, когда вы сознательно хотите нарушить совместимость со всеми существующими сериализациями, \n" +
                "например, когда изменения в вашем классе сделают его настолько семантически отличным, что у вас не будет выбора - в этом случае вы действительно должны несколько раз подумать о том, что вы на самом деле делаете.");
        core_1.add("- Проблема:  \n" +
                "В том что после десериализации мы получим другой объект. \n" +
                "Таким образом, сериализация дает возможность создать Singleton еще раз, что не совсем нужно. \n" +
                "- Решение:  \n" +
                "В классе определяется метод с сигнатурой \n" +
                "\"Object readResolve() throws ObjectStreamException\"  \n" +
                "// Назначение этого метода - возвращать замещающий объект вместо объекта, на котором он вызван.");
        core_1.add("- В Java, есть 3 способа клонирования объекта: \n" +
                "1. С использованием интерфейса Cloneable;\n" +
                "Первый способ подразумевает, что вы будете использовать механизм так называемого «поверхностного клонирования» и сами позаботитесь \n" +
                "о клонировании полей-объектов. \n" +
                "Метод clone() в родительском классе Object является protected, поэтому требуется переопределение его с объявлением как public. \n" +
                "Он возвращает экземпляр объекта с копированными полями-примитивами и ссылками. \n" +
                "И получается что у оригинала и его клона поля-ссылки указывают на одни и те же объекты. \n" +
                "2. С использованием конструктора клонирования объекта; \n" +
                "В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей поля нового объекта. \n" +
                "3. С использованием сериализации. \n" +
                "Он заключается в сохранении объекта в поток байтов с последующей эксгумацией его от туда.");
        core_1.add("- Поверхностное копирование копирует настолько малую часть информации, насколько это возможно. \n" +
                "По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует. \n" +
                "- Глубокое копирование дублирует все. Глубокое копирование — это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции. ");
        core_1.add("- Наиболее безопасным и следовательно предпочтительным способом клонирования является использование специализированного конструктора копирования:\n" +
                "Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод clone()); \n" +
                "Поля для клонирования указываются явно;\n" +
                "Возможность клонировать даже final поля.\n");
        core_1.add("- Метод clone() объявлен в классе Object с сигнатурой native, чтобы обеспечить доступ к стандартному механизму \"поверхностного копирования\" объектов (копируются значения всех полей, включая ссылки на сторонние объекты); \n" +
                "Он объявлен, как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. ");
        core_1.add("- Глубокое клонирование требует выполнения следующих правил: \n" +
                "  * Нет необходимости копировать отдельно примитивные данные; \n" +
                "  * Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться super.clone() при переопределении метода clone();\n" +
                " * Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.\n" +
                "Способы:\n" +
                "1. Сериализация – это еще один способ глубокого копирования. Мы просто сериализуем нужный объект и десериализуем его. Очевидно, объект должен поддерживать интерфейс Serializable. Мы сохраняет объект в массив байт и потом прочитать из него. \n" +
                "2. При помощи библиотеки DeepCloneable\n" +
                "Глубокое клонирование с этой библиотекой сводится к двум строкам кода:\n" +
                "Cloner cloner = new Cloner(); \n" +
                "DeepCloneable clone = cloner.deepClone(this); ");
        core_1.add("");
    }
}
