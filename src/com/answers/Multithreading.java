package com.answers;

import java.util.ArrayList;
import java.util.List;

public class Multithreading {

    public static List<String> multithreading = new ArrayList<>();

    static {
        multithreading.add("- Процесс — это экземпляр программы во время ее выполнения, т.е. независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве. Один процесс не может получить доступ к данным другого процесса.\n" +
                "И если процессу нужно получить доступ к ресурсам другого процесса, то ему надо организовать межпроцессное взаимодействие. \n" +
                "// Это могут быть: файлы, конвейеры, каналы связи между компьютерами и.т.д.\n" +
                "Операционная система - она отвечает за разграничение физической памяти для каждого процесса. И создает для него «виртуальное адресное пространство».\n" +
                "Процесс делится на потоки. В рамках одного процесса может находиться один или несколько потоков, которые существуют в пределах границ одного процесса.  \n" +
                "- Поток(thread) — это одна из частей выполнения процесса. И в каждом потоке код выполняется последовательно. \n" +
                "Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными. Также потоки расходуют меньше ресурсов чем процессы, и поэтому намного выгоднее создавать дополнительные потоки, чем дополнительные процессы.\n" +
                "// И еще: поток это - объект, реализующий интерфейс Runnable.");
        multithreading.add("- Thread - это класс, с помощью которого можно создать поток. \n" +
                "- Runnable - это интерфейс, который имеет более высокий уровень абстракции чем Thread. \n" +
                "В чем разница:\n" +
                "В классе Thread имеется несколько методов. Из них, в классе-наследнике, переопределять обязательно, нужно только метод run(). \n" +
                "Точно такой же метод run() есть и в интерфейсе Runnable. (Он там единственный). Потому что Thread сам как раз имплементирует Runnable (я проверял).\n" +
                "Создавать класс унаследованный от класса Thread, рекомендуется только в том случае, если надо дополнить его какими-то своими методами. \n" +
                "А если никакие методы из класса Thread переопределять не нужно, то тогда лучше использовать интерфейс Runnable. // В Runnable самая простая реализация. \n" +
                "// Тем более, реализация интерфейса Runnable позволяет создаваемому потоку наследовать любой другой класс, т.е не обязательно Thread использовать.\n" +
                "Также Runnable решает проблему множественного наследования. ");
        multithreading.add("- Монитор - это механизм (или сущность, котрая живет в каждом объекте) для синхронизации потоков, он обеспечивает доступ к ресурсам в каждом объекте. \n" +
                "Монитор встроен в класс Object и имеется у каждого объекта.\n" +
                "В Java - монитор активируется с помощью ключевого слова synchronized.\n" +
                "У каждого монитора есть некий - mutex. Мьютекс — это специальный объект для синхронизации потоков. \n" +
                "Mutex - это как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. Если не равен 0 – значит ресурс занят. // Это как замок.\n" +
                "Т. е. когда мьютекс монитора занят каким-то потоком, все остальные потоки стоят в очереди и ждут пока он станет свободным.\n" +
                " ");
        multithreading.add("- Синхронизация это механизм, который позволяет выполнять потоки параллельно. \n" +
                "В Java все объекты имеют блокировку, т.е. который обеспечивается монитором. И благодаря этой блокировке(монитору) - только один поток может одновременно  получить доступ к коду объекта. Такая синхронизация, во первых не дает повредить сам объект, во вторых благодаря ей - потоки не могут пользоваться объектом одновременно.\n" +
                "Способы синхронизации в Java: \n" +
                "-- С использованием wait() и notify(). \n" +
                "Это когда мы используем ключевое слово sinchronyzed или sinchronyzed-блоки. И внутри (метода или синхр-блока) прописываем методы wait() и notify().\n" +
                "Получается - поток захватывает монитор объекта, выполняет какие-то действия с объектом, и при определенных условиях вызывает у этого объекта метод wait(). \n" +
                "После вызова wait() - монитор освобождается, а этот поток ждет, пока где-то, какой-нибудь другой поток, не вызовет метод notify().\n" +
                "И после его вызова, первый ждущий на объекте поток «просыпается» и может продолжать свою работу. // Может и не продолжать. В зависимости от условий.\n" +
                "Потом, методы wait() и notify() - они не синхронизированы. И поэтому захват монитора надо делать в явном виде, например в synchronized-блоке.\n" +
                "-- С использованием join(). \n" +
                "join() - метод, который может быть вызван у объекта класса Thread.\n" +
                "Он позволяет текущему потоку остановиться и подождать, пока другой поток, связанный с этим же объектом, не закончит свою работу.\n" +
                "-- С использованием классов из пакета java.util.concurrent.Locks. Там тоже есть механизмы для синхронизации потоков, и это хорошая альтернатива базовым: synchronized, wait, notify, notifyAll. Там есть такие как: Интерфейс Lock с методами lock(), unlock(), tryLock(); (Это уже не системная синхронизация).");
        multithreading.add("- wait(): приостанавливает поток, ждет пока другой поток не вызовет метод notify() или notifyAll(); \n" +
                "- notify(): продолжает работу потока, у которого еще раньше был вызван метод wait(); \n" +
                "- notifyAll(): продолжает работу всех потоков, у которых тоже раньше был вызван метод wait().\n" +
                "Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting). \n" +
                "Метод notify() подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние Работоспособный (Runnable). \n" +
                "Метод notifyAll() подаёт сигнал всем ожидающим потокам, чтобы они вернулись в состояние Работоспособный (Runnable). \n" +
                "Если никто из потоков не находится в ожидании, т.е. не вызывали метод wait(), то при вызове notify() или notifyAll() ничего не происходит.\n" +
                "\n");
        multithreading.add("- New (Новый) - объект класса создан в потоке, но еще не запущен. Он пока что только создан и еще не выполняется.\n" +
                "- Runnable (Работоспособный) - поток готов к выполнению, но планировщик его еще не выбрал.\n" +
                "- Running (Запущенный) – поток выполняется.\n" +
                "- Waiting, blocked или sleeping (Ожидающий) - поток блокирован, либо поток ждет окончания работы другого потока.\n" +
                " (Либо спит).\n" +
                "- Dead (Остановленный) - поток умер, т.е завершен (run())//Если поток завершен, а мы вызываем метод start() (для dead потока), то будет выброшено исключение.\n"+
                "У класса Thread есть внутренний класс-перечисление State (состояние), а также метод getState().\n" +
                "public enum State \n" +
                "{\n" +
                " NEW, — поток создан, но еще не запущен;\n" +
                " \n" +
                "  RUNNABLE, — поток в рабочем состоянии;\n" +
                " \n" +
                "  BLOCKED, — поток блокирован;\n" +
                " \n" +
                "  WAITING, — поток ждет окончания работы другого потока;\n" +
                " \n" +
                "  TIMED_WAITING, — поток ждет окончания другого потока, некоторое время;\n" +
                " \n" +
                "  TERMINATED; — поток завершен.\n" +
                "\n" +
                "}\n");
        multithreading.add("- Semaphore – это тоже синхронизатор, только со счётчиком. Изначальное значение счетчика задается в конструкторе. \n" +
                "Когда поток заходит в заданный блок кода, то значение счетчика уменьшается на единицу, когда поток его покидает, то увеличивается. \n" +
                "Если значение счетчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защенного блока.\n" +
                "Т.е. семафор - он ограничивает доступ к объекту какому-то определенному числу потоков. \n" +
                "Например к одному ресурсу могут обращаться не больше 5-ти потоков. // Для получения разрешения у семафора надо вызвать метод acquire().\n" +
                "// Semaphore - используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве. Например: подключение к базе данных в пуле.");
        multithreading.add("- Volatile - это модификатор. Он отключает кэширование переменной, чтобы эту переменную могли использовать все потоки. Т.е. делает ее общей.\n" +
                "// Потом, переменная с ключевым словом: volatile - находится в хипе, а не в кэше стека.\n" +
                "Переменная volatile является атомарной только для чтения. Но если происходит какая-то другая операция, например: инкримент, то атомарности уже не будет. \n" +
                "Потому что сначала выполняется чтение(1), потом изменение(2), а затем запись(3). \n" +
                "Такая операция не является атомарной, потому что, где-то по середине, (между операциями) в неё может вклиниться другой поток. \n" +
                "А атомарная операция - это операция которая выполняется только за ОДИН ШАГ. \n");
        multithreading.add("- Вот volatile ведь не гарантирует атомарность. \n" +
                "А вот например - class AtomicInteger - предоставляет атомарные методы, чтобы можно было выполнять нескольких операций - атомарно. \n" +
                "Метод: getAndIncrement() – его можно использовать вместо оператора инкремента, // Чтобы увеличивать значение переменной - атомарно. \n" +
                "Также, кроме AtomicInteger - есть похожие классы, но уже для других типов данных.");
        multithreading.add("- Потоки-демоны - это потоки для обслуживания основных потоков (приложения) в фоновом режиме. Запускаются они с помощью метода setDaemon(boolean value), и вызываются у обычного потока перед его запуском. \n" +
                "Как только выполнится основной поток (метод main()) - выполнение потока-демона тоже завершается, даже если поток-демон еще работает.\n" +
                "А обычные потоки не могут принудительно остановить поток-демон.\n" +
                "Метод isDaemon() позволяет определить, является ли указанный поток демоном или нет. \n" +
                "Бывает так что когда программа заканчивается, а поток-демон все еще продолжает работать. // Поэтому он и Демон. \n" +
                "Примером для потока-демона является сбор мусора.");
        multithreading.add("- Приоритеты потоков - их устанавливает планировщик потоков. Он решает, когда и какому потоку можно работать. (и ставит их в очередь).\n" +
                "Значит, в чем разница: Потоки с высоким приоритетом - они получают больше процессорного времени, чем потоки с низким приоритетом. \n" +
                "// Но не всегда. Там бывают еще и другие критерии: например - является ли поток демоном или нет.\n" +
                " А у демона - самый низкий приоритет.\n" +
                "Для установки приоритета (у потока) вызывается метод setPriority(int level). Значение level можно указывать от MIN_PRIORITY = 1 до MAX_PRIORITY = 10.  \n" +
                "По умолчанию стоит - NORM_PRlORITY = 5. \n" +
                "Чтобы узнать, какой приоритет у потока, можно вызвать метод: getPriority(). \n" +
                "Также можно выполнить любой поток принудительно, т.е. не взирая на приоритет, с помощью метода yield(). // Метод yield() - уступает место другому потоку.");
        multithreading.add("- Метод join(), позволяет дожидаться, пока тот поток, к которому он присоединен, не завершит свою работу. \n" +
                "Либо пока этот поток не отработает время переданное в параметры метода join(long millis) - а там время указывается в миллисекундах. \n" +
                "Это может использоваться, например: Когда мы, сначала распараллелили все потоки, а потом, чтобы снова слить их всех в кучу - надо дождаться результатов вычисления всех остальных потоков.");
        multithreading.add("- Метод yield() - он возвращает выполняющийся поток в состоянии runnable (работоспособный), для того чтобы уступить место другому потоку.\n" +
                "Метод - sleep () - приостанавливает выполнение потока на указанное время, в параметрах метода.");
        multithreading.add("- Метод stop() - останавливает поток, но слишком грубо, потому что не дожидается других потоков. Он не является потокобезопасным. И он Deprecated.\n" +
                "- Метод interrupt() - более безопасен чем stop(). Но работает по другому: Через метод interrupt() мы просто посылаем сигнал потоку, что хотим его прервать.\n" +
                "А если этот сигнал будет проигнорирован, то поток может и не остановится. Потом метод - interrupt() устанавливает статус прерывания(прервался поток или нет).\n" +
                "А у метода interrupted(), как я понял все то же самое, только статус прерывания, при вызове, сбрасывается.\n" +
                "- Метод isInterrupted() - он проверят статус: прервался ли поток или нет. // Но при этом он вызывается из другого потока.");
        multithreading.add("- Интерфейс Runnable появился раньше чем Callable (Callable находится в библиотеке java.util.concurrent).\n" +
                "Классы, реализующие интерфейс Runnable, чтобы выполнить свои задачи должны реализовывать метод run(). \n" +
                "Классы, реализующие интерфейс Callable - метод call();\n" +
                "Метод run() не возвращает никакого значения. Он void. \n" +
                "А метод call() возвращает дженерик, т.е. то что в него параметризовали (потому что Callable - это параметризованный функциональный интерфейс).\n" +
                "Также метод run() НЕ может выбрасывать исключения, а метод call() может.");
        multithreading.add("- Этот класс, который используется для асинхронных вычислений в параллельном потоке. // Реализует интерфейсы Future и Runnable.\n" +
                "У него есть методы для запуска (и остановки) какого-то вычисления, и также методы для получения результатов этих вычислений, в будущем.\n" +
                "// Методы run(), get(); \n" +
                "А результат вычислений - будет получен только тогда, когда вычисление завершено. А до тех пор - метод получения результата будет заблокирован. \n" +
                "В конструктор он принимает объекты Runnable и Callable. (это я в идее проверял).");
        multithreading.add("- Взаимная блокировка (deadlock) - это такое явление, когда все потоки находятся в режиме ожидания и при этом ничего не делают. \n" +
                "Какие могут быть причины: \n" +
                "- взаимное исключение: когда какой-то один ресурс занят, и два или несколько потоков не могут его поделить. \n" +
                "- цикличное ожидание: когда поток ждет освобождения ресурса другим потоком, а тот поток ждёт освобождения ресурса, заблокированного первым потоком. \n" +
                "(Одно из часто встречающихся). (Можно привести пример со стульями).           \n" +
                "Чтобы не допустить взаимной блокировки, надо просто не допускать цикличного ожидания. \n" +
                "Т.е можно освобождать мониторы ,разделяемых ресурсов, в обратном порядке. Т.е. если они блокировались в одном порядке, то освобождать в другом порядке.\n" +
                "Ну еще надо как-то изначально правильно строить архитектуру своего многопоточного приложения.");
        multithreading.add("- livelock – это тоже взаимная блокировка, когда несколько потоков выполняют бесполезную работу.\n" +
                "Когда они пытаются получить какие-либо ресурсы, то они зацикливаются. И при этом их состояния могут постоянно изменяться.  \n" +
                "Есть такой пример из жизни: – Когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону, и при этом не продвигаются в нужном им направлении.");
        multithreading.add("- Race condition - это состояние гонки, т.е. это когда программист как-то неправильно спроектировал свое приложение... многопоточное. \n" +
                "Иии.. когда поток, который должен исполнится в самом начале, проиграл гонку другому потоку и первым исполняется вот этот другой поток. \n" +
                "Затем - поведение кода может измениться, и из-за этого возникают ошибки. \n" +
                "Есть два распространенных типа состояния гонки:\n" +
                "DataRace (Гонка данных) - это когда потоки гонятся за данными. И начинают конфликтовать между собой (например, когда идет: чтение или запись в одну и ту же переменную).\n" +
                "Starvation (Голодание) - это когда происходит нехватка данных, (и при этом потоки не заблокированы), из-за этого потоки просто ничего не делают.\n" +
                "Например - потоки с низким приоритетом голодают, потому что потоки с высоким приоритетом - все ресурсы расхватывают намного быстрее, в первую очередь.\n" +
                "Чтобы решить проблему стостояния гонок - можно синхронизировать потоки специальными методами или синхронайзед-блоками. ");
        multithreading.add("- Fork/Join - это такой фреймворк для работы с потоками. Он короче - разбивает задачи на более мелкие подзадачи, которые могут выполняться парралельно. \n" +
                "Есть два этапа, у него:\n" +
                "Этап Fork: большая задача разделяется на более мелкие - до тех пор, пока одна из задач не станет настолько простой, что решить ее можно последовательно.\n" +
                "Этап Join: это когда решения подзадач начинают объединяться, до тех пор, пока не получится решение всей задачи полностью.\n" +
                "Все это происходит параллельно. Потом... \n" +
                "для решения некоторых задач этап Join не требуется. \n" +
                "Ещё одно преимущество этого фреймворка заключается в том, что он использует алгоритм work-stealing: это значит что - потоки которые закончили свои подзадачи, могут «украсть» подзадачи у других потоков, которые всё ещё заняты. То есть оказывают им помощь. :)");
        multithreading.add("- Synchronized предназначено для синхронизации потоков в методах или synchronized-блоках.\n" +
                "Если блок кода пометить как - synchronized, то компилятор заменяет его тремя кусками кода: \n" +
                "1) В начале блока добавляется код, который отмечает мютекс как занятый. \n" +
                "2) В конце блока добавляется код, который отмечает мютекс как свободный. \n" +
                "3) А перед блоком (synchronized-блоком) добавляется код, который смотрит, если мютекс занят – то все остальные потоки должны ждать его освобождения. ");
        multithreading.add("- У статического - является объект типа Class, ну смотря, в каком классе определен метод.\n" +
                "Если мы создаем объект статического (вложенного) класса, - все что находится в этом объекте – принадлежит статическому классу. \n" +
                "Потом, в случае вызова статического метода - память выделяется только один раз.");
        multithreading.add("- Здесь монитором будет объект this.\n" +
                "А если вызывается нестатический синхронизированный метод, то память выделяется многократно, каждый раз, т.е. при каждом вызове метода. ");
        multithreading.add("- java.util.concurrent - это пакет, который содержит в себе - специальные классы и интерфейсы для работы с потоками. \n" +
                "- Concurrent Collections это — набор коллекций, для работы в многопоточной среде. Они более эффективные чем стандартные коллекции из java.util пакета. (collections) Например такие как: CopyOnWriteArrayList(Set), ConcurrentHashMap.\n" +
                " Не помню больше. Но кажется названия такие же, с добавлением Concurrent.\n" +
                "Здесь особенность в том, что: Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии внутреннего массива. И этим гарантируется, что при проходе итератором по коллекции не будет выброшено исключение: ConcurrentModificationException.\n" +
                "- Queues — это неблокирующие очереди и блокирующие очереди, с поддержкой многопоточности. \n" +
                "Неблокирующие очереди работают быстрее блокирующих. И работают без блокирования потоков. \n" +
                "Блокирующие очереди используются, когда нужно «притормозить» потоки, в зависимости от условий. Например, если очередь пуста или переполнена. \n" +
                "- Executors - это интерфейс, который позволяют управлять потоками, и выполнять какие то задачи. Ну там внутри него только один метод exequte();\n" +
                "- ExecutorService -  он наследник интерфейса Executor. Тоже предназначен для управления потоками, а точнее пулом потоков. \n" +
                "Имеет метод: execute(Runnable thread), который пришел от Executorsa; И метод: Метод shotdown().\n" +
                "- Lock — интерфейс. Его объекты блокируют доступ к ресурсам или блокам. Помоему намного удобнее чем synchronized. Методы: lock(), unlock(), trylock().\n" +
                "- Atomic - Классы - для выполнения атомарных операций. Преимущество этих классов в том, что можно не использовать всякие там блокировки, и синхронизации (synchronized).\n" +
                "\n" +
                "- Synchronizers - вспомогательные утилиты для синхронизации потоков. С помощью них можно управлять или ограничивать работу нескольких потоков. \n" +
                "\n" +
                "Synchronizers содержит пять объектов синхронизации: semaphore, countDownLatch, ciclycBarrier, exchanger, phaser.\n" +
                "-- Semaphore – это синхронизатор со счётчиком. При создании синхронизатора, изначальное значение счетчика задается в конструкторе. Когда поток заходит в заданный блок кода, то значение счетчика уменьшается на единицу, а когда поток его покидает, то увеличивается. Если значение счетчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищенного блока. \n" +
                "-- CountDownLatch - тоже для синхронизации потоков. Он будет блокировать потоки до тех пор, пока не будут выполнены определенные условия. Количество условий задается счетчиком. При обнулении счетчика, т.е. при выполнении всех условий, блокировки выполняемых потоков будут сняты, и потоки продолжат выполнение кода. (Используется один раз). \n" +
                "-- CyclicBarrier — барьерная синхронизация, останавливает поток в определенном месте в ожидании прихода остальных потоков группы. Как только все потоки достигнут барьера, барьер снимается и выполнение потоков продолжается. Здесь тоже используется счетчик, как в CountDownLatch. Только здесь барьер можно использовать повторно(в цикле).\n" +
                " \n" +
                "-- Phaser — тоже как «Барьер», только в отличие от CyclicBarrier, может иметь несколько барьеров (фаз), и количество потоков на каждой фазе может быть разным. \n" +
                "-- Exchanger — используется синхронизации потоков, а также для обмена данными между двумя потоками. При обмене данными допускается null значения. \n" +
                "Обмен данными между потоками происходит только после вызова метода exchange() у обоих потоков.");
        multithreading.add("- Stream (интерфейс) - это последовательность элементов, над которой можно производить разные операции.\n" +
                "- Внутри этого Stream API есть способы распараллеливания потока. Один из них - метод parallelStream(). \n" +
                "Метод parallelStream() - (он по умолчанию) использует ForkJoinPool.commonPool. // Собственно, поэтому они и связаны (Stream API и ForkJoinPool). \n" +
                "Ну а ForkJoinPool – он также используется в ExecutorService (пулл потоков). И предназначен для выполнения параллельных задач. ");
        multithreading.add("");
    }
}
