package com.answers;

import java.util.ArrayList;
import java.util.List;

public class Patterns {

    public static List<String> patterns = new ArrayList<>();

    static {
        patterns.add("- Шаблон (паттерн) проектирования — это шаблон по которому будет проектироваться наш проект, т.е. уже готовое и проверенное к использованию решение. \n" +
                "Это означает то - как ты будешь делать(создавать) свое приложение, по какому образу и подобию.\n" +
                "Это не класс и не библиотека, которую можно подключить к проекту, и шаблон проектирования может быть реализован в разных языках программирования. \n" +
                "Шаблон нужен, чтобы не изобретать колесо каждый раз когда надо сделать что-то новое. \n" +
                "\n" +
                "Плюсы использования шаблонов: \n" +
                "• снижение сложности разработки за счёт готовых абстракций. \n" +
                "• облегчение коммуникации между разработчиками, благодаря тому что - все они ссылаются на известные шаблоны. \n" +
                "• унификация всех модулей и элементов проекта, т.е. приведение их к единообразной форме. \n" +
                "• если кто-то нашел хорошее решение, то есть возможность - пользоваться им снова и снова. \n" +
                "• из всех вариантов, можно выбрать наиболее подходящий вариант проектирования. \n" +
                "\n" +
                "Минусы: \n" +
                "• это когда кто-то применяет шаблон, там где он не нужен. И это может привести к усложнению программы. \n" +
                "• когда кто-то хочет попробовать некоторый шаблон в деле без особых на то оснований.                        +++++");
        patterns.add("- Имя - у каждого шаблона есть уникальное имя, для его идентификации;\n" +
                "- \n" +
                "Назначение, т.е. цель данного шаблона;\n" +
                "- \n" +
                "Задача, которую этот шаблон позволяет решить;\n" +
                "- \n" +
                "Способ решения, т.е. каким способом будет решаться данная задача именно в том контексте, где этот шаблон был найден;\n" +
                "\n" +
                "- Участники - это те сущности, которые принимают участие в решении задачи;\n" +
                "\n" +
                "- Следствия от использования шаблона, т.е. какой результат будет получен;\n" +
                " \n" +
                "- Реализация - это когда имеется несколько вариантов для реализации шаблона.                                +++++");
        patterns.add("- Порождающие паттерны. Это когда мы можем создавать какие-то объекты без внесения в программу лишних зависимостей.\n" +
                "- Структурные паттерны. Это когда мы можем связывать наши объекты различными способами.\n" +
                "- Поведенческие паттерны. Это когда мы можем обеспечить коммуникацию между объектами.            +++++");
        patterns.add("- Singleton - это такой порождающий паттерн проектирования, который гарантирует, что у какого-то класса будет создан только один экземпляр, \n" +
                "и он помимо этого еще сможет предоставлять глобальную точку доступа.\n" +
                "\n" +
                "У Синглтона - обычно конструктор помечается как private, а для создания нового объекта Singleton использует специальный метод (getInstance() или др.название) \n" +
                "Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.  \n" +
                "\n" +
                "\n" +
                "Например в нашем классе Singlton - пишем:\n" +
                "\n" +
                "private static Singleton instance; \n" +
                "\n" +
                "\n" +
                "\n" +
                "public static Singleton getInstance() {\n" +
                "       \n" +
                "\tif (instance == null) {\n" +
                "                   // Проверку на NULL - нужно обязательно делать, иначе каждый раз будет возвращаться новый объект.  \n" +
                "\t\tinstance = new Singleton();\n" +
                "                \n" +
                "\t}\n" +
                "       \n" +
                "\treturn instance;\n" +
                "   \n" +
                "}\n" +
                "\n" +
                "\n" +
                "Потом, чтобы получить экземпляр класса Singlton, оператор new уже применить не получится. А придется получать синглтон из метода getInstance();\n" +
                "\n" +
                "Плюсы:   если у нас имеются какие-то ресурсоемкие задачи, то можно не создавать много объектов, а пользоваться одним. \n" +
                "\n" +
                "// Это может быть полезно для доступа к какому-то общему ресурсу, например, к базе данных.\n" +
                "Минусы : то что он нарушает принцип единой ответственности SOLID, потому что его могут использовать много объектов.\n" +
                "\n" +
                "* Почему считается антипаттерном?\n" +
                " \n" +
                "- Потому что объекты Singlton нельзя тестировать с помощью mock, но можно использовать powerMock.\n" +
                " \n" +
                "- Потому что этот паттерн нарушает принцип единой ответственности SOLID. \n" +
                "\n" +
                "- Потому что этот паттерн нарушает Open/Close принцип SOLID, и из-за этого классы Singlton-ов нельзя расширить.\n" +
                "\n" +
                "* Можно ли его синхронизировать без ключевого слова synchronized у метода? \n" +
                "\n" +
                "- Можно. Для этого объект Синглтона нужно сделать Enum-ом (eager). То есть сделать статический final класс с константами. \n" +
                "И так как JVM загружает final и static классы на этапе компиляции, то это означает что несколько потоков не смогут создавать несколько экземпляров класса. \n" +
                "\n" +
                "- C помощью ключевых слов double checked locking (lazy). Но в таком случае ключевое слово synchronized будет указываться внутри метода:\n" +
                "\n" +
                "private static volatile Singleton instance; \n" +
                "\n" +
                "\n" +
                "\n" +
                "public static Singleton getInstance() { \n" +
                "    \n" +
                "\tSingleton localInstance = instance; \n" +
                "        \n" +
                "\n" +
                "\tif (localInstance == null) { \n" +
                "                                          // первая проверка \n" +
                "             \n" +
                "\t\tsynchronized (Singleton.class) { \n" +
                "                 \n" +
                "\t\tlocalInstance = instance; \n" +
                "                      \n" +
                "\t\t\tif (localInstance == null) { \n" +
                "                          // вторая проверка\n" +
                "                          \n" +
                "\t\t\t\tinstance = localInstance = new Singleton(); \n" +
                "                      \n" +
                "\t\t\t} \n" +
                "              \n" +
                "\t\t}\n" +
                "       \n" +
                "\t} \n" +
                "    return localInstance; \n" +
                "\n" +
                "}                                                                                                        +++++");
        patterns.add("- Паттерн Builder - это такой порождающий паттерн, с помощью которого можно создавать какие-то очень сложные объекты пошагово. \n" +
                "И у строителя обычно, хотя внутри используется один и тот же код, но в нем можно строить самые разные объекты. \n" +
                "Потом - у паттерна Строитель - объекты обычно конструируются  где-то за пределами его собственного класса, и он поручает это дело отдельным объектам, \n" +
                "которые так и называются -  строители. \n" +
                "Сам процесс конструирования объекта - обычно разбивается на отдельные этапы(шаги) конструирования (например, построитьСтены, вставитьДвери). \n" +
                "Для того чтобы создать объект, надо поочерёдно вызывать методы строителя. И при чем не обязательно запускать все методы, а можно запускать только те, \n" +
                "которые нам нужны для конструирования объекта.\n" +
                "Также бывает что - методы строителя вызываются в каком-то отдельном классе, который называется Директором. \n" +
                "И этот директор может задавать порядок шагов строительства, а строители будет их выполнять.\n" +
                "Короче, я как понял. Что строитель можно использовать как с директором, так и без директора - но тогда мы сами будем вызывать нужные нам методы строителя.\n" +
                "\n" +
                "Плюсы: Позволяет использовать один и тот же код для создания различных объектов. А также изолирует сложный код сборки объектов от его основной бизнес-логики. \n" +
                "Минусы : Усложняет код программы из-за введения дополнительных классов.                              +++++");
        patterns.add("- Фабричный метод (Factory Method) - это такой порождающий паттерн, его еще называют виртуальный конструктор. \n" +
                "Он, получается, предоставляет своим дочерним подклассам интерфейс, для создания объектов какого-то класса. \n" +
                "Но решение о том - какие именно объекты, т.е объекты какого именно класса нужно создавать происходит в подклассах. \n" +
                "// То есть какой-то базовый класс или интерфейс делегирует создание объектов своим классам-наследникам.\n" +
                "\n" +
                "С помощью паттерн Фабричный метод мы не создаем объекты не напрямую, используя оператор new, а объект создается через вызов особого фабричного метода. \n" +
                "// Ну вот как в Синглтоне. Или например, точно также как мы бины извлекаем из контейнера в Spring-е.\n" +
                "Объекты также и создаются при помощи new, но только все это происходит в фабричном методе.\n" +
                "\n" +
                "Короче, я так понял: Вот у нас есть какой-то класс, и мы этот класс имплементируется от какого-то интерфейса. И от этого интерфейса мы получаем методы, которые нужно реализовать для создания объектов какого-то класса. Т.е. внутри этих методов будут создаваться конкретные объекты.\n" +
                "\n" +
                "// Например у нас есть интерфейс Логистика и два класса: Дорожная логистика и Морская логистика.\n" +
                "\n" +
                "Обычно этот паттерн используется:\n" +
                "- когда классу заранее неизвестно, объекты каких подклассов ему нужно создавать.\n" +
                "- когда класс спроектирован так, чтобы объекты, которые он создаёт, определяли свое назначение внутри его подклассов.                   +++++ ");
        patterns.add("- Это такой порождающий паттерн проектирования. И он предлагает интерфейс для создания других классов. // А создавать он будет - семейства каких-то классов. \n" +
                "И он не привязывается к конкретным классам создаваемых объектов.\n" +
                "Паттерн Абстрактная фабрика выделяет общие интерфейсы для отдельных продуктов, составляющих семейства или группы. \n" +
                "Например, когда все виды кресел реализуют интерфейс Кресло, а все диваны реализуют интерфейс Диван и так далее. \n" +
                "Затем создается еще один общий интерфейс, внутри которого есть фабричные методы для создания сразу всех продуктов семейства по отдельности(например, создать Кресло, создать Диван и создать Столик). \n" +
                "И эти методы возвращают не конкректные объекты, а какие-то абстрактные типы продуктов, представленные интерфейсами, которые мы выделили ранее — Кресла, Диваны и Столики.\n" +
                "\n" +
                "// Получается у нас - создаются не конкректные объекты, а абстрактные типы, т.е. семейства каких-то продуктов.\n" +
                "\n" +
                "Плюсы: Это то что гарантированно будет создаваться тип какого-то одного семейства. \n" +
                "Минусы : Это то что данный паттерн - усложняет код программы из-за введения множества дополнительных классов.               +++++");
        patterns.add("- Prototype - это порождающий паттерн проектирования, который позволяет создавать объекты на основе уже ранее созданных объектов-прототипов.  \n" +
                "\n" +
                "То есть - создание нового объекта происходит не через конструктор, а происходит путем клонирования от раннее созданного объекта. \n" +
                "Объекты, которые поддерживают клонирование, клонируются методом clone(), который находится в Object-e. (И еще есть такой маркерный интерфейс Cloneable).\n" +
                "Получается метод объекта какого-то класса создаёт новый объект этого же класса и копирует в него значения всех своих полей.  \n" +
                "\n" +
                "То есть, как я понял: объект создает новый объект на основе самого себя.\n" +
                " \n" +
                "Плюсы:   Позволяет клонировать объекты, не привязываясь к их конкретным классам. \n" +
                "Минусы : Сложно клонировать какие-то связанные объекты, т.е имеющие ссылки на другие объекты.                         +++++");
        patterns.add("- Adapter - это структурный паттерн проектирования, который обеспечивает связь несовместимых объектов между собой. \n" +
                "Например, когда есть объект-переводчик, который трансформирует данные одного объекта в такой вид, чтобы он стал понятен другому объекту.\n" +
                "И при этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого.\n" +
                "\n" +
                "Применение:\n" +
                "Когда например, нужно использовать сторонний класс, но его интерфейс не соответствует нашему коду приложения.\n" +
                "Адаптер как-бы создает прокладку, который будет превращать реализацию кода написанного на каком-то другом языке в формат, понятный нашему языку.\n" +
                "Или пример из жизни: Это когда мы USB-флэшку вставляем в разъем компьютера.\n" +
                " \n" +
                "Плюсы:   Отделяет и скрывает подробности преобразования интерфейсов объектов.\n" +
                "Минусы : То что он усложняет код программы из-за введения дополнительных классов.                                +++++");
        patterns.add("- Decorator это - структурный паттерн проектирования. Он оборачивает объекты в полезные обертки, и при этом добавляет им новую функциональность. \n" +
                "// Например классы-обертки.\n" +
                "То есть, когда какой-то объект помещается в другой объект (объект-обёртку). А тот объект-обертка - сначала запускает основное поведение обёрнутого объекта, а потом может еще добавить что-то своё, т.е. какую-то свою дополнительную функциональность. \n" +
                "Оба эти объекта будут иметь общий интерфейс, и поэтому для пользователя без разницы, с каким объектом работать — с чистым или с обёрнутым. \n" +
                "Прикол в том, что здесь можно использовать несколько разных обёрток одновременно — т.е. результат будет иметь объединённое поведение всех обёрток сразу. \n" +
                "При использовании паттерна Декоратор состояние объекта может измениться, в отличии от паттерна Адаптера, который не менят состояния объекта.\n" +
                "  \n" +
                "Плюсы:   Большая гибкость, чем у наследования.\n" +
                "Минусы : Если объекты обернуты многократно, то их будет труднее конфигурировать.                               +++++");
        patterns.add("- Proxy - это структурный паттерн проектирования. Он короче, вместо реальных объектов, подставляет другие объекты, которые становятся его заместителями. \n" +
                "И вот эти заместители - могут перехватывать запросы к оригинальному объекту. При этом они позволяют выполнить какую-то промежуточную логику: До того как вызов дойдет до оригинального-объекта или же После передачи вызова оригиналу. \n" +
                "То есть паттерн Proxy - создает новые классы-дублёры, которые имеют такие же интерфейсы, что и оригинальные объекты. \n" +
                "Также объект-заместитель может выполнять роль защитника оригинального объекта. Т.е. он как-бы может принимать все удары на себя. \n" +
                "И при этом - пользователь или клиент, даже не будет подозревать, что имеет дело не с оригиналом а с его заместителем.\n" +
                "\n" +
                "Плюсы:   Позволяет контролировать обслуживаемый объект незаметно для клиента.\n" +
                "Минусы : Увеличивает время отклика от сервиса.                                                                 +++++");
        patterns.add("- Iterator - это поведенческий паттерн проектирования. С помощью него можно последовательно обходить элементы коллекций (составных объектов), // не раскрывая их внутреннего представления. \n" +
                "И благодаря такому подходу - обход коллекции происходит не в самой коллекции, а выносится в отдельный класс. \n" +
                "\n" +
                "Детали: Получается, создается объект итератор и интерфейс, который возвращает этот итератор.\n" +
                "\n" +
                "Короче, я делал так: \n" +
                " Set<Integer> set = new HashSet<>();\n" +
                "\n" +
                "        for(int i=0; i<10; i++){\n" +
                "            set.add((int) (Math.random()*(100+1)));\n" +
                "        }\n" +
                "\n" +
                "//        Iterator iterator = set.iterator();                              // Я делал перебор с помощью Iteratora.\n" +
                "\n" +
                "//        while(iterator.hasNext()){                                       // Так.\n" +
                "//\n" +
                "//            System.out.println(iterator.next());\n" +
                "//        }\n" +
                "\n" +
                "        for (Iterator iterator = set.iterator(); iterator.hasNext(); ){    // Или так.\n" +
                "            System.out.println(iterator.next());\n" +
                "        }                                                                                      +++++");
        patterns.add("- Template - это поведенческий паттерн проектирования. Это когда мы можем разбить какой-то алгоритм на последовательность шагов, а затем эти шаги мы можем описать в отдельных методах, и уже потом эти методы можем вызывать в одном ШАБЛОННОМ методе - друг за другом.\n" +
                "То есть, как я понял, паттерн Template сначала определяет скелет алгоритма, затем разбивает его на отдельные шаги.\n" +
                "\n" +
                "И еще он позволяет наследникам переопределять некоторые шаги данного алгоритма, при этом структура всего алгоритма не изменяется. \n" +
                "\n" +
                "Для описания шагов можно использовать абстрактный класс. Получается общие шаги можно будет описать в абстрактном класе. \n" +
                "А потом его подклассы могут переопределять некоторые шаги алгоритма, приэтом все его остальные шаги и его структура - останутся без изменений. \n" +
                "\n" +
                "Это может применяться, когда - например, у нас имеется несколько классов, делающих одно и то же, но с незначительными отличиями. \n" +
                "В таком случае - общие действия могут прописываться в классе-родителе, и при необходимости могут переопределяться в классах-наследниках.\n" +
                "\n" +
                "И это позволяет убрать дублирование кода в нескольких классах с похожим поведением, но отличающихся в деталях.             \n" +
                "// Как я понял - речь тут идет о наследовании.)                                                                            +++++");
        patterns.add("- Цепочка обязанностей - это поведенческий паттерн проектирования. Он позволяет передавать запросы последовательно - по цепочке обработчиков.\n" +
                "Получается, у каждого обработчика - будут свои обязанности. \n" +
                "Каждый из этих обработчиков решает, может ли он обработать запрос или нет, и стоит ли вообще этот запрос передавать дальше по цепи (следующему обработчику).\n" +
                " \n" +
                "Основная идея данного паттерна в том, чтобы каждая проверка производилась в отдельном классе, и в единственном методе.\n" +
                "\n" +
                "Происходит все это следующим образом: \n" +
                "Получается, данные запроса передаваются в параметры определенного метода, и уже потом проверяются в этом методе.\n" +
                "В каждом из этих методов содержится ссылка на следующий метод-обработчик. В результате - образуется цепочка методов-обработчиков со своими обязанностями.\n" +
                "Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке. \n" +
                "А может и не передавать, например - если проверка в одном из методов не прошла, то тогда он не передаст. \n" +
                "\n" +
                "Плюсы:  Реализует принцип единственной обязанности.\n" +
                "Минусы: Запрос может остаться так никем и не обработанным.             +++++");
        patterns.add("- Singleton - Bean scopes. \n" +
                "- \n" +
                "Factory - Bean Factory classes. \n" +
                "- \n" +
                "Prototype - Bean scopes\n" +
                ". \n" +
                "- Adapter - Spring Web and Spring MVC\n" +
                ". \n" +
                "- Proxy - Spring Aspect Oriented Programming support. \n" +
                "\n" +
                "- Template Method - JdbcTemplate, HibernateTemplate etc\n" +
                ". \n" +
                "- Front Controller - Spring MVC DispatcherServlet. // Это один из паттернов MVC. Означает что есть какая-то единая точка входа для всех входящих запросов.\n" +
                "- \n" +
                "DAO - Spring Data Access Object support.         // Это когда создается прослойка между БД и какой-то бизнес логикой.\n" +
                "- \n" +
                "Dependency Injection.                                                                                                     +++++");
        patterns.add("- Domain Model – это объектная модель предметной области. Она включает в себя как поведение так и данные.\n" +
                " // Например класс User.\n" +
                "- Data Mapper – слой мапперов (Mappers). Это - передача данных между объектами и базой данных, сохраняя их независимыми друг от друга. \n" +
                "- \n" +
                "Proxy  — применяется для ленивой загрузки.\n" +
                " \n" +
                "- Factory — используется в SessionFactory.                                                                 +++++");
        patterns.add("");
    }
}
